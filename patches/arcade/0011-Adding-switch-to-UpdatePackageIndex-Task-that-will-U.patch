From e4ba8cba5d103afa3490d4a1846dd89f960b72d1 Mon Sep 17 00:00:00 2001
From: Jose Perez Rodriguez <joperezr@microsoft.com>
Date: Fri, 30 Aug 2019 10:28:35 -0700
Subject: [PATCH 11/11] Adding switch to UpdatePackageIndex Task that will
 Update stable versions (#3802)

* Adding switch to UpdatePackageIndex Task that will Update stable versions

* Change to use NuGet APIs and addressing PR feedback

* Adding ability to perform repo-wide update of stable package info without requiring nuspec or nupkg
---
 .../src/NuGetUtility.cs                       |  98 ++++++++++++
 .../src/UpdatePackageIndex.cs                 |  31 +++-
 ...alidateHarvestVersionIsLatestForRelease.cs | 143 ++++++++++++++++++
 .../src/build/Packaging.targets               |  17 ++-
 4 files changed, 285 insertions(+), 4 deletions(-)
 create mode 100644 src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetUtility.cs
 create mode 100644 src/Microsoft.DotNet.Build.Tasks.Packaging/src/ValidateHarvestVersionIsLatestForRelease.cs

diff --git a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetUtility.cs b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetUtility.cs
new file mode 100644
index 00000000..45f99550
--- /dev/null
+++ b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetUtility.cs
@@ -0,0 +1,98 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+// See the LICENSE file in the project root for more information.
+
+using NuGet.Common;
+using NuGet.Configuration;
+using NuGet.Protocol;
+using NuGet.Protocol.Core.Types;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.DotNet.Build.Tasks.Packaging
+{
+    public static class NuGetUtility
+    {
+        internal static IEnumerable<Version> GetAllVersionsForPackageId(string packageId, bool includePrerelease, bool includeUnlisted, Log log, CancellationToken cancellationToken)
+        {
+            List<Version> result = new List<Version>();
+            ISettings settings = Settings.LoadDefaultSettings(Directory.GetCurrentDirectory());
+            IEnumerable<PackageSource> enabledSources = GetEnabledSources(settings);
+            var logger = new NuGetLogger(log);
+            Parallel.ForEach(enabledSources, (packageSource) =>
+            {
+                 using (var sourceCacheContext = new SourceCacheContext())
+                 {
+                     var sourceRepository = new SourceRepository(packageSource, Repository.Provider.GetCoreV3());
+                     var packageMetadataResource = sourceRepository.GetResourceAsync<PackageMetadataResource>().GetAwaiter().GetResult();
+                     var searchMetadata = packageMetadataResource.GetMetadataAsync(packageId, includePrerelease, includeUnlisted, sourceCacheContext, logger, cancellationToken).GetAwaiter().GetResult();
+                     foreach (IPackageSearchMetadata packageMetadata in searchMetadata)
+                     {
+                         lock (result)
+                         {
+                            Version threePartVersion = VersionUtility.As3PartVersion(packageMetadata.Identity.Version.Version);
+                            if (!result.Contains(threePartVersion))
+                                result.Add(threePartVersion);
+                         }
+                     }
+                 }
+            });
+            // Given we are looking in different sources, we reorder all versions.
+            return result.OrderBy(v => v);
+        }
+
+        private static IEnumerable<PackageSource> GetEnabledSources(ISettings settings)
+        {
+            if (settings == null)
+            {
+                throw new ArgumentNullException(nameof(settings));
+            }
+
+            var provider = new PackageSourceProvider(settings);
+            return provider.LoadPackageSources().Where(e => e.IsEnabled == true).ToList();
+        }
+
+        public static Version GetLatestPatchStableVersionForRelease(this IEnumerable<Version> versions, int eraMajorVersion, int eraMinorVersion)
+        {
+            return versions.Where(v => VersionUtility.As2PartVersion(v) == new Version(eraMajorVersion, eraMinorVersion))
+                           .OrderByDescending(v => v)
+                           .FirstOrDefault();
+        }
+
+        internal class NuGetLogger : ILogger
+        {
+            private readonly Log _log;
+
+            public NuGetLogger(Log log)
+            {
+                _log = log;
+            }
+
+            public void Log(LogLevel level, string data) => _log.LogMessage($"{level.ToString()} - {data}");
+
+            public void Log(ILogMessage message) => _log.LogMessage(message.ToString());
+
+            public Task LogAsync(LogLevel level, string data) => Task.Run(() => Log(level, data));
+
+            public Task LogAsync(ILogMessage message) => Task.Run(() => Log(message));
+
+            public void LogDebug(string data) => _log.LogMessage(data);
+
+            public void LogError(string data) => _log.LogError(data);
+
+            public void LogInformation(string data) => _log.LogMessage(data);
+
+            public void LogInformationSummary(string data) => _log.LogMessage(data);
+
+            public void LogMinimal(string data) => _log.LogMessage(data);
+
+            public void LogVerbose(string data) => _log.LogMessage(data);
+
+            public void LogWarning(string data) => _log.LogWarning(data);
+        }
+    }
+}
diff --git a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/UpdatePackageIndex.cs b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/UpdatePackageIndex.cs
index cfc4dc19..d7bed456 100644
--- a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/UpdatePackageIndex.cs
+++ b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/UpdatePackageIndex.cs
@@ -1,4 +1,4 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 // See the LICENSE file in the project root for more information.
 
@@ -6,11 +6,14 @@
 using Newtonsoft.Json;
 using NuGet.Frameworks;
 using NuGet.Packaging;
+using NuGet.Protocol.Core.Types;
 using NuGet.Versioning;
 using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Threading;
+using System.Threading.Tasks;
 
 namespace Microsoft.DotNet.Build.Tasks.Packaging
 {
@@ -75,6 +78,8 @@ public class UpdatePackageIndex : BuildTask
 
         public bool SetBaselineVersionsToLatestStableVersion { get; set; }
 
+        public bool UpdateStablePackageInfo { get; set; }
+
         /// <summary>
         /// Pre-release version to use for all pre-release packages covered by this index.
         /// </summary>
@@ -180,6 +185,17 @@ public override bool Execute()
                 }
             }
 
+            if (UpdateStablePackageInfo && Packages == null && PackageFolders == null)
+            {
+                // Given we will query the web for every package, we should run in parallel to try to optimize the performance.
+                Parallel.ForEach(index.Packages, (package) =>
+                {
+                    IEnumerable<Version> stablePackageVersions = NuGetUtility.GetAllVersionsForPackageId(package.Key, includePrerelease: false, includeUnlisted: false, Log, CancellationToken.None);
+                    package.Value.StableVersions.Clear();
+                    package.Value.StableVersions.AddRange(stablePackageVersions);
+                });
+            }
+
             if (!String.IsNullOrEmpty(PreRelease))
             {
                 index.PreRelease = PreRelease;
@@ -249,6 +265,19 @@ private void UpdateFromValues(PackageIndex index, string id, NuGetVersion versio
         {
             PackageInfo info = GetOrCreatePackageInfo(index, id);
 
+            if (UpdateStablePackageInfo)
+            {
+                try
+                {
+                    IEnumerable<Version> allStableVersions = NuGetUtility.GetAllVersionsForPackageId(id, includePrerelease: false, includeUnlisted: false, Log, CancellationToken.None);
+                    info.StableVersions.AddRange(allStableVersions);
+                }
+                catch(NuGetProtocolException)
+                {
+                    Log.LogWarning("Failed fetching stable nuget package versions from one or more of your feeds. Make sure you are connected to the internet and that all your feeds are reachable.");
+                }
+            }
+
             var packageVersion = VersionUtility.As3PartVersion(version.Version);
             // if we have a stable version, add it to the stable versions list
             if (!version.IsPrerelease)
diff --git a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/ValidateHarvestVersionIsLatestForRelease.cs b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/ValidateHarvestVersionIsLatestForRelease.cs
new file mode 100644
index 00000000..31329a85
--- /dev/null
+++ b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/ValidateHarvestVersionIsLatestForRelease.cs
@@ -0,0 +1,143 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+// See the LICENSE file in the project root for more information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+using NuGet.Versioning;
+using System;
+using System.Collections.Generic;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.DotNet.Build.Tasks.Packaging
+{
+    /// <summary>
+    /// MSBuild Task that validates if a package is harvesting
+    /// the latest package version for a specific package release.
+    /// </summary>
+    public class ValidateHarvestVersionIsLatestForRelease : BuildTask
+    {
+        /// <summary>
+        /// Item containing all package reports where the item spec is the path to the report.
+        /// </summary>
+        [Required]
+        public ITaskItem[] PackageReports { get; set; }
+
+        public override bool Execute()
+        {
+            // Run all validations in parallel
+            Parallel.ForEach(PackageReports, (reportPath) => ValidateHarvestVersionForReport(reportPath.ItemSpec));
+            return !Log.HasLoggedErrors;
+        }
+
+        private void ValidateHarvestVersionForReport(string packageReportPath)
+        {
+            PackageReport packageReport = GetPackageReportFromPath(packageReportPath);
+            bool isHarvestingAssetsFromPackage = TryGetHarvestVersionFromReport(packageReport, out string harvestVersion, out int harvestMajor, out int harvestMinor);
+
+            if (isHarvestingAssetsFromPackage)
+            {
+                if (packageReport.Version.StartsWith($"{harvestMajor}.{harvestMinor}."))
+                {
+                    Log.LogError($"Validation Failed: {packageReport.Id} is harvesting package version {harvestVersion} which belongs to the current package release: {packageReport.Version}");
+                    return;
+                }
+
+                string latestPatchVersion = GetLatestStableVersionForPackageRelease(packageReport.Id, harvestMajor, harvestMinor);
+                if (latestPatchVersion.CompareTo(harvestVersion) != 0)
+                {
+                    Log.LogError($"Validation Failed: {packageReport.Id} is harvesting assets from package version {harvestVersion} which is not the latest for that package release. Latest package version from that release is {latestPatchVersion}. In order to fix this, run `dotnet msbuild {packageReport.Id}.pkgproj /t:UpdatePackageIndex /p:UpdateStablePackageInfo=true`");
+                }
+                else
+                {
+                    Log.LogMessage(LogImportance.Normal, $"Validation Succeeded: {packageReport.Id} is harvesting assets from package version {harvestVersion} which is the latest for that package erreleasea.");
+                }
+            }
+            else
+            {
+                Log.LogMessage(LogImportance.Normal, $"Validation Succeeded: {packageReport.Id} is not harvesting any assets.");
+            }
+        }
+
+        // Making this method protected virtual for tests.
+        protected virtual PackageReport GetPackageReportFromPath(string path)
+        {
+            return PackageReport.Load(path);
+        }
+
+        private bool TryGetHarvestVersionFromReport(PackageReport report, out string harvestVersion, out int harvestMajor, out int harvestMinor)
+        {
+            harvestVersion = string.Empty;
+            harvestMajor = harvestMinor = 0;
+
+            foreach (KeyValuePair<string, Target> packageTarget in report.Targets.NullAsEmpty())
+            {
+                foreach (PackageAsset compileAsset in packageTarget.Value.CompileAssets.NullAsEmpty())
+                {
+                    if (!string.IsNullOrEmpty(compileAsset.HarvestedFrom))
+                    {
+                        return GetHarvestVersionFromString(compileAsset.HarvestedFrom, report.Id, out harvestVersion, out harvestMajor, out harvestMinor);
+                    }
+                }
+
+                foreach (PackageAsset runtimeAsset in packageTarget.Value.RuntimeAssets.NullAsEmpty())
+                {
+                    if (!string.IsNullOrEmpty(runtimeAsset.HarvestedFrom))
+                    {
+                        return GetHarvestVersionFromString(runtimeAsset.HarvestedFrom, report.Id, out harvestVersion, out harvestMajor, out harvestMinor);
+                    }
+                }
+
+                foreach (PackageAsset nativeAsset in packageTarget.Value.NativeAssets.NullAsEmpty())
+                {
+                    if (!string.IsNullOrEmpty(nativeAsset.HarvestedFrom))
+                    {
+                        return GetHarvestVersionFromString(nativeAsset.HarvestedFrom, report.Id, out harvestVersion, out harvestMajor, out harvestMinor);
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        private bool GetHarvestVersionFromString(string harvestedFrom, string packageId, out string harvestVersion, out int harvestMajor, out int harvestMinor)
+        {
+            harvestVersion = string.Empty;
+            harvestMajor = harvestMinor = 0;
+            string patternToSearchFor = $"{packageId}/";
+            int startIndex = harvestedFrom.IndexOf(patternToSearchFor);
+            if (startIndex != -1)
+            {
+                startIndex += patternToSearchFor.Length;
+                int endIndex = harvestedFrom.IndexOf("/", startIndex);
+                if (endIndex != -1)
+                {
+                    harvestVersion = harvestedFrom.Substring(startIndex, endIndex - startIndex);
+                    NuGetVersion harvestPackageVersion = new NuGetVersion(harvestVersion);
+                    harvestMajor = harvestPackageVersion.Major;
+                    harvestMinor = harvestPackageVersion.Minor;
+                    return true;
+                }
+                else
+                {
+                    Log.LogError($"Failed to parse package version from string: {harvestedFrom}");
+                    return false;
+                }
+            }
+            else
+            {
+                Log.LogError($"Failed to parse package version from string: {harvestedFrom}");
+                return false;
+            }
+        }
+
+        // Making this method protected virtual for tests.
+        protected virtual string GetLatestStableVersionForPackageRelease(string packageId, int releaseMajorVersion, int releaseMinorVersion)
+        {
+            IEnumerable<Version> packageVersions = NuGetUtility.GetAllVersionsForPackageId(packageId, includePrerelease: false, includeUnlisted: false, Log, CancellationToken.None); 
+            Version latestPatchVersion = packageVersions.GetLatestPatchStableVersionForRelease(releaseMajorVersion, releaseMinorVersion);
+            return (latestPatchVersion == null) ? string.Empty : $"{latestPatchVersion.Major}.{latestPatchVersion.Minor}.{latestPatchVersion.Build}";
+        }
+    }
+}
diff --git a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/build/Packaging.targets b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/build/Packaging.targets
index 1dad25df..4743eb1f 100644
--- a/src/Microsoft.DotNet.Build.Tasks.Packaging/src/build/Packaging.targets
+++ b/src/Microsoft.DotNet.Build.Tasks.Packaging/src/build/Packaging.targets
@@ -1282,8 +1282,13 @@
     <Error Condition="'$(PackageIndexFile)' == ''"
            Text="The PackageIndexFile property is not set.  Please set this property to point to the path of the packageIndex.json file for your repo." />
 
+    <PropertyGroup>
+      <UpdateStablePackageInfo Condition="'$(UpdateStablePackageInfo)' == ''">true</UpdateStablePackageInfo>
+    </PropertyGroup>
+
     <UpdatePackageIndex PackageIndexFile="$(PackageIndexFile)"
-                        Packages="$(PackageOutputPath)$(Id).$(PackageVersion).nupkg" />
+                        Packages="$(PackageOutputPath)$(Id).$(PackageVersion).nupkg"
+                        UpdateStablePackageInfo="$(UpdateStablePackageInfo)" />
   </Target>
 
   <!-- Updates the packageIndex with information from the multiple sources for the entire repo -->
@@ -1299,7 +1304,12 @@
     <!-- Set ModuleToPackage to module name identity with 'Package' metadata to define mappings from native modules to package IDs which contain those -->
     <!-- Set FrameworkListsFolder to the path to a set of directories containing framework lists, where the subdirectory name is the TFM.  These lists will determine what is inbox on that framework. -->
     <!-- Set FrameowrkLayout to folder identity with 'TargetFramework' metadata to consider files within that folder inbox on that framework.-->
-
+    <!-- Set UpdateStablePackageInfo to true in order to go through all the package index and update the stable version information for all the packages in the index.-->
+    
+    <ItemGroup>
+      <PackageFolders Include="$(PackageFolders)" />
+    </ItemGroup>
+      
     <UpdatePackageIndex PackageIndexFile="$(PackageIndexFile)"
                         PackageIds="@(PackageIds)"
                         PackageFolders="@(PackageFolders)"
@@ -1307,6 +1317,7 @@
                         StablePackages="@(StablePackage)"
                         ModuleToPackages="@(ModuleToPackage)"
                         InboxFrameworkListFolder="$(FrameworkListsFolder)"
-                        InboxFrameworkLayoutFolders="@(FrameworkLayout)" />
+                        InboxFrameworkLayoutFolders="@(FrameworkLayout)"
+                        UpdateStablePackageInfo="$(UpdateStablePackageInfo)" />
   </Target>
 </Project>
-- 
2.18.0

