From f926d1acf0826c87512b23369adb648268ce503d Mon Sep 17 00:00:00 2001
From: Chris Rummel <crummel@microsoft.com>
Date: Wed, 6 Feb 2019 17:22:18 -0600
Subject: [PATCH] Update arcade.

---
 eng/Publishing.props                          |  42 ++
 eng/build.yml                                 | 105 ++++
 eng/common/CIBuild.cmd                        |   3 +-
 eng/common/PublishBuildAssets.cmd             |   2 +-
 eng/common/PublishToPackageFeed.proj          |  37 ++
 eng/common/README.md                          |  28 ++
 eng/common/build.ps1                          |  88 ++--
 eng/common/build.sh                           | 248 ++++++----
 eng/common/darc-init.ps1                      |  25 +-
 eng/common/darc-init.sh                       |  13 +-
 eng/common/helixpublish.proj                  |  13 +-
 eng/common/msbuild.ps1                        |  14 +-
 eng/common/msbuild.sh                         |  21 +-
 eng/common/sdk-task.ps1                       |  74 +++
 eng/common/templates/job/job.yml              | 205 ++++++++
 .../templates/job/publish-build-assets.yml    |  63 +++
 eng/common/templates/jobs/jobs.yml            |  77 +++
 eng/common/templates/phases/base.yml          |   1 -
 .../templates/phases/publish-build-assets.yml |   2 +-
 eng/common/templates/steps/helix-publish.yml  |   5 +-
 eng/common/templates/steps/send-to-helix.yml  |  81 ++++
 eng/common/templates/steps/telemetry-end.yml  |   4 -
 .../templates/steps/telemetry-start.yml       |   9 +-
 eng/common/tools.ps1                          | 457 +++++++++++++-----
 eng/common/tools.sh                           | 211 +++++---
 eng/configure-toolset.ps1                     |   8 +-
 eng/configure-toolset.sh                      |   5 +
 27 files changed, 1469 insertions(+), 372 deletions(-)
 create mode 100644 eng/Publishing.props
 create mode 100644 eng/build.yml
 create mode 100644 eng/common/PublishToPackageFeed.proj
 create mode 100644 eng/common/README.md
 create mode 100644 eng/common/sdk-task.ps1
 create mode 100644 eng/common/templates/job/job.yml
 create mode 100644 eng/common/templates/job/publish-build-assets.yml
 create mode 100644 eng/common/templates/jobs/jobs.yml
 create mode 100644 eng/common/templates/steps/send-to-helix.yml
 create mode 100644 eng/configure-toolset.sh

diff --git a/eng/Publishing.props b/eng/Publishing.props
new file mode 100644
index 0000000..7e13c8a
--- /dev/null
+++ b/eng/Publishing.props
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
+<Project>
+
+  <PropertyGroup>
+    <Product>Toolset</Product>
+    <BlobStoragePartialRelativePath>$(Product)</BlobStoragePartialRelativePath>
+    <BlobStoragePartialRelativePath Condition="'$(IsNotOrchestratedPublish)' == 'false'">assets/$(Product)</BlobStoragePartialRelativePath>
+    <SdkAssetsManifestFilePath>$(ArtifactsLogDir)AssetManifest\$(OS)-$(PlatformName)-SdkAssets.xml</SdkAssetsManifestFilePath>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <SdkAssetsToPublish Include="$(ArtifactsShippingPackagesDir)*.zip" />
+  </ItemGroup>
+  
+  <Target Name="PublishCoreSdkAssets" BeforeTargets="Publish" Condition="$(PublishToAzure)">
+    <PropertyGroup>
+      <Version Condition=" '$(VersionSuffix)' != '' ">$(VersionPrefix)-$(VersionSuffix)</Version>
+      <Version Condition=" '$(Version)' == '' ">$(VersionPrefix)</Version>
+    </PropertyGroup>
+
+    <ItemGroup>
+      <SdkAssetsToPushToBlobFeed Include="@(SdkAssetsToPublish)" IsShipping="true" >
+        <RelativeBlobPath>$(BlobStoragePartialRelativePath)/$(Version)/$([System.String]::Copy('%(Filename)%(Extension)').Replace('\' ,'/'))</RelativeBlobPath>
+        <ManifestArtifactData>ShipInstaller=dotnetcli</ManifestArtifactData>
+      </SdkAssetsToPushToBlobFeed>
+    </ItemGroup>
+
+    <PushToBlobFeed
+      ExpectedFeedUrl="$(DotNetPublishBlobFeedUrl)"
+      AccountKey="$(DotNetPublishBlobFeedKey)"
+      ItemsToPush="@(SdkAssetsToPushToBlobFeed)"
+      ManifestBuildData="Location=$(DotNetPublishBlobFeedUrl)"
+      ManifestRepoUri="$(BUILD_REPOSITORY_URI)"
+      ManifestBranch="$(BUILD_SOURCEBRANCH)"
+      ManifestBuildId="$(BUILD_BUILDNUMBER)"
+      ManifestCommit="$(BUILD_SOURCEVERSION)"
+      AssetManifestPath="$(SdkAssetsManifestFilePath)"
+      PublishFlatContainer="true" />
+  </Target>
+
+</Project>
diff --git a/eng/build.yml b/eng/build.yml
new file mode 100644
index 0000000..f32cab2
--- /dev/null
+++ b/eng/build.yml
@@ -0,0 +1,105 @@
+parameters:
+  agentOs: ''
+  queue: {}
+  variables: {}
+
+phases:
+- template: /eng/common/templates/phases/base.yml
+  parameters:
+    name: ${{ parameters.agentOs }}
+    enableTelemetry: true
+    publicBuildReasons: PullRequest
+    queue: ${{ parameters.queue }}
+    variables: 
+      ${{ insert }}: ${{ parameters.variables }}
+      _AgentOSName: ${{ parameters.agentOs }}
+      _HelixType: build/product
+      _HelixBuildConfig: $(_BuildConfig)
+      BuildConfig: $(_BuildConfig)
+      BuildArchitecture: $(_BuildArchitecture)
+      DockerParameter: $(_DockerParameter)
+      LinuxPortable: $(_LinuxPortable)
+      RuntimeId: $(_RuntimeIdentifier)
+      ${{ if eq(variables['System.TeamProject'], 'public') }}:
+        _HelixSource: pr/dotnet/toolset/$(Build.SourceBranch)
+        _OfficialBuildIdArgs: ''
+        _PublishArgs: ''
+      ${{ if ne(variables['System.TeamProject'], 'public') }}:
+        _HelixSource: official/dotnet/toolset/$(Build.SourceBranch)
+        _OfficialBuildIdArgs: /p:OfficialBuildId=$(BUILD.BUILDNUMBER)
+        _PublishArgs: /p:DotNetPublishToBlobFeed=$(_DotNetPublishToBlobFeed)
+                  /p:DotNetPublishBlobFeedUrl=$(PB_PublishBlobFeedUrl)
+                  /p:DotNetPublishBlobFeedKey=$(dotnetcli-storage-key)
+                  /p:DotNetSymbolServerTokenMsdl=$(microsoft-symbol-server-pat)
+                  /p:DotNetSymbolServerTokenSymWeb=$(symweb-symbol-server-pat)
+                  /p:PB_PublishType=$(_PublishType)
+
+    steps:
+    - ${{ if ne(variables['System.TeamProject'], 'public') }}:
+      - task: AzureKeyVault@1
+        inputs:
+          azureSubscription: 'DotNet-Engineering-Services_KeyVault'
+          KeyVaultName: EngKeyVault
+          SecretsFilter: 'dotnetcli-storage-key,microsoft-symbol-server-pat,symweb-symbol-server-pat'
+        condition: succeeded()
+      - task: AzureKeyVault@1
+        inputs:
+          azureSubscription: 'HelixProd_KeyVault'
+          KeyVaultName: HelixProdKV
+          SecretsFilter: 'HelixApiAccessToken'
+        condition: always()
+
+    - ${{ if eq(parameters.agentOs, 'Windows_NT') }}:
+      - script: build.cmd
+                  -pack -publish -ci -test
+                  -Configuration $(BuildConfig)
+                  -Architecture $(BuildArchitecture)
+                  $(_PublishArgs)
+                  $(_OfficialBuildIdArgs)
+        displayName: Build
+
+    - ${{ if eq(parameters.agentOs, 'Linux') }}:
+      - script: ./build.sh
+                  --pack --publish --ci --test
+                  --configuration $(BuildConfig)
+                  $(DockerParameter)
+                  --architecture $(BuildArchitecture)
+                  $(LinuxPortable)
+                  $(RuntimeId)
+        displayName: Build
+
+    - ${{ if eq(parameters.agentOs, 'Darwin') }}:
+      - script: ./build.sh
+                  --pack --publish --ci --test
+                  --configuration $(BuildConfig)
+        displayName: Build
+
+    - task: PublishTestResults@1
+      displayName: Publish Test Results
+      inputs:
+        testRunner: XUnit
+        testResultsFiles: 'artifacts/TestResults/$(_BuildConfig)/*.xml'
+        testRunTitle: '$(_AgentOSName)_$(Agent.JobName)'
+        platform: '$(BuildPlatform)'
+        configuration: '$(_BuildConfig)'
+      condition: and(succeededOrFailed(), ne(variables['PB_SkipTests'], 'true'), ne(variables['RunTests'], 'false'))
+
+    - task: CopyFiles@2
+      displayName: Gather Logs
+      inputs:
+        SourceFolder: '$(Build.SourcesDirectory)'
+        Contents: |
+         artifacts/log/$(_BuildConfig)/**/*
+         artifacts/TestResults/$(_BuildConfig)/**/*
+        TargetFolder: '$(Build.ArtifactStagingDirectory)'
+      continueOnError: true
+      condition: always()
+
+    - task: PublishBuildArtifacts@1
+      displayName: Publish Logs to VSTS
+      inputs:
+        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
+        ArtifactName: '$(_AgentOSName)_$(Agent.JobName)_$(Build.BuildNumber)'
+        publishLocation: Container
+      continueOnError: true
+      condition: always()
diff --git a/eng/common/CIBuild.cmd b/eng/common/CIBuild.cmd
index 6544b0c..56c2f25 100644
--- a/eng/common/CIBuild.cmd
+++ b/eng/common/CIBuild.cmd
@@ -1,3 +1,2 @@
 @echo off
-powershell -ExecutionPolicy ByPass -NoProfile -command "& """%~dp0Build.ps1""" -restore -build -test -sign -pack -publish -ci %*"
-exit /b %ErrorLevel%
+powershell -ExecutionPolicy ByPass -NoProfile -command "& """%~dp0Build.ps1""" -restore -build -test -sign -pack -publish -ci %*"
\ No newline at end of file
diff --git a/eng/common/PublishBuildAssets.cmd b/eng/common/PublishBuildAssets.cmd
index 4f9d54d..3c6e4ff 100644
--- a/eng/common/PublishBuildAssets.cmd
+++ b/eng/common/PublishBuildAssets.cmd
@@ -1,3 +1,3 @@
 @echo off
-powershell -ExecutionPolicy ByPass -NoProfile -command "& """%~dp0Build.ps1""" -restore -publishBuildAssets %*"
+powershell -ExecutionPolicy ByPass -NoProfile -command "& """%~dp0sdk-task.ps1""" -msbuildEngine dotnet -restore -projects PublishBuildAssets.proj -ci %*"
 exit /b %ErrorLevel%
diff --git a/eng/common/PublishToPackageFeed.proj b/eng/common/PublishToPackageFeed.proj
new file mode 100644
index 0000000..7dc478d
--- /dev/null
+++ b/eng/common/PublishToPackageFeed.proj
@@ -0,0 +1,37 @@
+<!--
+  This MSBuild file is intended to be used as the body of the default 
+  publishing release pipeline. The release pipeline will use this file
+  to invoke the PushToStaticFeed task that will read the build asset
+  manifest and publish the assets described in the manifest to
+  informed target feeds.
+-->
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFramework>netcoreapp2.1</TargetFramework>
+  </PropertyGroup>
+
+  <Import Project="$(MSBuildThisFileDirectory)MicrosoftDotNetBuildTasksFeedVersion.props" />
+  <Import Project="$(NuGetPackageRoot)microsoft.dotnet.build.tasks.feed\$(MicrosoftDotNetBuildTasksFeedVersion)\build\Microsoft.DotNet.Build.Tasks.Feed.targets" />
+
+  <Target Name="PublishToFeed">
+    <Error Condition="'$(TargetStaticFeed)' == ''" Text="TargetStaticFeed: Target feed for publishing assets wasn't provided." />
+    <Error Condition="'$(AccountKeyToStaticFeed)' == ''" Text="AccountKeyToStaticFeed: Account key for target feed wasn't provided." />
+    <Error Condition="'$(FullPathAssetManifest)' == ''" Text="Full path to asset manifest wasn't provided." />
+    <Error Condition="'$(FullPathBlobBasePath)' == '' AND '$(FullPathPackageBasePath)' == ''" Text="A valid full path to BlobBasePath of PackageBasePath is required." />
+
+    <PushArtifactsInManifestToFeed
+      ExpectedFeedUrl="$(TargetStaticFeed)"
+      AccountKey="$(AccountKeyToStaticFeed)"
+      Overwrite="$(OverrideAssetsWithSameName)"
+      PassIfExistingItemIdentical="$(PassIfExistingItemIdentical)"
+      MaxClients="$(MaxParallelUploads)"
+      UploadTimeoutInMinutes="$(MaxUploadTimeoutInMinutes)"
+      AssetManifestPath="$(FullPathAssetManifest)"
+      BlobAssetsBasePath="$(FullPathBlobBasePath)"
+      PackageAssetsBasePath="$(FullPathPackageBasePath)" />
+  </Target>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.DotNet.Build.Tasks.Feed" Version="$(MicrosoftDotNetBuildTasksFeedVersion)" />
+  </ItemGroup>
+</Project>
diff --git a/eng/common/README.md b/eng/common/README.md
new file mode 100644
index 0000000..ff49c37
--- /dev/null
+++ b/eng/common/README.md
@@ -0,0 +1,28 @@
+# Don't touch this folder
+
+                uuuuuuuuuuuuuuuuuuuu
+              u" uuuuuuuuuuuuuuuuuu "u
+            u" u$$$$$$$$$$$$$$$$$$$$u "u
+          u" u$$$$$$$$$$$$$$$$$$$$$$$$u "u
+        u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
+      u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
+    u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
+    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
+    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
+    $ $$$" ... "$...  ...$" ... "$$$  ... "$$$ $
+    $ $$$u `"$$$$$$$  $$$  $$$$$  $$  $$$  $$$ $
+    $ $$$$$$uu "$$$$  $$$  $$$$$  $$  """ u$$$ $
+    $ $$$""$$$  $$$$  $$$u "$$$" u$$  $$$$$$$$ $
+    $ $$$$....,$$$$$..$$$$$....,$$$$..$$$$$$$$ $
+    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
+    "u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
+      "u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
+        "u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
+          "u "$$$$$$$$$$$$$$$$$$$$$$$$" u"
+            "u "$$$$$$$$$$$$$$$$$$$$" u"
+              "u """""""""""""""""" u"
+                """"""""""""""""""""
+
+!!! Changes made in this directory are subject to being overwritten by automation !!!
+
+The files in this directory are shared by all Arcade repos and managed by automation. If you need to make changes to these files, open an issue or submit a pull request to https://github.com/dotnet/arcade first.
diff --git a/eng/common/build.ps1 b/eng/common/build.ps1
index ca45b3d..8279dc7 100644
--- a/eng/common/build.ps1
+++ b/eng/common/build.ps1
@@ -1,14 +1,14 @@
 [CmdletBinding(PositionalBinding=$false)]
 Param(
-  [string] $configuration = "Debug",
-  [string] $projects = "",
-  [string] $verbosity = "minimal",
+  [string][Alias('c')]$configuration = "Debug",
+  [string] $projects,
+  [string][Alias('v')]$verbosity = "minimal",
   [string] $msbuildEngine = $null,
-  [bool] $warnaserror = $true,
-  [bool] $nodereuse = $true,
-  [switch] $restore,
+  [bool] $warnAsError = $true,
+  [bool] $nodeReuse = $true,
+  [switch][Alias('r')]$restore,
   [switch] $deployDeps,
-  [switch] $build,
+  [switch][Alias('b')]$build,
   [switch] $rebuild,
   [switch] $deploy,
   [switch] $test,
@@ -17,7 +17,7 @@ Param(
   [switch] $sign,
   [switch] $pack,
   [switch] $publish,
-  [switch] $publishBuildAssets,
+  [switch][Alias('bl')]$binaryLog,
   [switch] $ci,
   [switch] $prepareMachine,
   [switch] $help,
@@ -28,14 +28,15 @@ Param(
 
 function Print-Usage() {
     Write-Host "Common settings:"
-    Write-Host "  -configuration <value>  Build configuration Debug, Release"
-    Write-Host "  -verbosity <value>      Msbuild verbosity (q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic])"
+    Write-Host "  -configuration <value>  Build configuration: 'Debug' or 'Release' (short: -c)"
+    Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+    Write-Host "  -binaryLog              Output binary log (short: -bl)"
     Write-Host "  -help                   Print help and exit"
     Write-Host ""
 
     Write-Host "Actions:"
-    Write-Host "  -restore                Restore dependencies"
-    Write-Host "  -build                  Build solution"
+    Write-Host "  -restore                Restore dependencies (short: -r)"
+    Write-Host "  -build                  Build solution (short: -b)"
     Write-Host "  -rebuild                Rebuild solution"
     Write-Host "  -deploy                 Deploy built VSIXes"
     Write-Host "  -deployDeps             Deploy dependencies (e.g. VSIXes for integration tests)"
@@ -45,7 +46,6 @@ function Print-Usage() {
     Write-Host "  -performanceTest        Run all performance tests in the solution"
     Write-Host "  -sign                   Sign build outputs"
     Write-Host "  -publish                Publish artifacts (e.g. symbols)"
-    Write-Host "  -publishBuildAssets        Push assets to BAR"
     Write-Host ""
 
     Write-Host "Advanced settings:"
@@ -58,24 +58,35 @@ function Print-Usage() {
     Write-Host "The above arguments can be shortened as much as to be unambiguous (e.g. -co for configuration, -t for test, etc.)."
 }
 
-if ($help -or (($properties -ne $null) -and ($properties.Contains("/help") -or $properties.Contains("/?")))) {
-  Print-Usage
-  exit 0
+function InitializeCustomToolset {
+  if (-not $restore) {
+    return
+  }
+
+  $script = Join-Path $EngRoot "restore-toolset.ps1"
+
+  if (Test-Path $script) {
+    . $script
+  }
 }
 
-try {
-  if ($projects -eq "") {
-    $projects = Join-Path $RepoRoot "*.sln"
+function Build {
+  $toolsetBuildProj = InitializeToolset
+  InitializeCustomToolset
+
+  $bl = if ($binaryLog) { "/bl:" + (Join-Path $LogDir "Build.binlog") } else { "" }
+
+  if ($projects) {
+    # Re-assign properties to a new variable because PowerShell doesn't let us append properties directly for unclear reasons.
+    # Explicitly set the type as string[] because otherwise PowerShell would make this char[] if $properties is empty.
+    [string[]] $msbuildArgs = $properties
+    $msbuildArgs += "/p:Projects=$projects"
+    $properties = $msbuildArgs
   }
 
-  InitializeTools
-
-  $BuildLog = Join-Path $LogDir "Build.binlog"
-
-  MSBuild $ToolsetBuildProj `
-    /bl:$BuildLog `
+  MSBuild $toolsetBuildProj `
+    $bl `
     /p:Configuration=$configuration `
-    /p:Projects=$projects `
     /p:RepoRoot=$RepoRoot `
     /p:Restore=$restore `
     /p:DeployDeps=$deployDeps `
@@ -88,16 +99,29 @@ try {
     /p:PerformanceTest=$performanceTest `
     /p:Sign=$sign `
     /p:Publish=$publish `
-    /p:PublishBuildAssets=$publishBuildAssets `
     /p:ContinuousIntegrationBuild=$ci `
     @properties
+}
 
-  if ($lastExitCode -ne 0) {
-    Write-Host "Build Failed (exit code '$lastExitCode'). See log: $BuildLog" -ForegroundColor Red
-    ExitWithExitCode $lastExitCode
+try {
+  if ($help -or (($properties -ne $null) -and ($properties.Contains("/help") -or $properties.Contains("/?")))) {
+    Print-Usage
+    exit 0
   }
 
-  ExitWithExitCode $lastExitCode
+  if ($ci) {
+    $binaryLog = $true
+    $nodeReuse = $false
+  }
+
+  # Import custom tools configuration, if present in the repo.
+  # Note: Import in global scope so that the script set top-level variables without qualification.
+  $configureToolsetScript = Join-Path $EngRoot "configure-toolset.ps1"
+  if (Test-Path $configureToolsetScript) {
+    . $configureToolsetScript
+  }
+
+  Build
 }
 catch {
   Write-Host $_
@@ -105,3 +129,5 @@ catch {
   Write-Host $_.ScriptStackTrace
   ExitWithExitCode 1
 }
+
+ExitWithExitCode 0
diff --git a/eng/common/build.sh b/eng/common/build.sh
index 941db3b..4fe8b41 100755
--- a/eng/common/build.sh
+++ b/eng/common/build.sh
@@ -1,5 +1,39 @@
 #!/usr/bin/env bash
 
+# Stop script if unbound variable found (use ${var:-} if intentional)
+set -u
+
+# Stop script if command returns non-zero exit code.
+# Prevents hidden errors caused by missing error code propagation.
+set -e
+
+usage()
+{
+  echo "Common settings:"
+  echo "  --configuration <value>    Build configuration: 'Debug' or 'Release' (short: --c)"
+  echo "  --verbosity <value>        Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+  echo "  --binaryLog                Create MSBuild binary log (short: -bl)"
+  echo ""
+  echo "Actions:"
+  echo "  --restore                  Restore dependencies (short: -r)"
+  echo "  --build                    Build all projects (short: -b)"
+  echo "  --rebuild                  Rebuild all projects"
+  echo "  --test                     Run all unit tests (short: -t)"
+  echo "  --sign                     Sign build outputs"
+  echo "  --publish                  Publish artifacts (e.g. symbols)"
+  echo "  --pack                     Package build outputs into NuGet packages and Willow components"
+  echo "  --help                     Print help and exit (short: -h)"
+  echo ""
+  echo "Advanced settings:"
+  echo "  --projects <value>       Project or solution file(s) to build"
+  echo "  --ci                     Set when running on CI server"
+  echo "  --prepareMachine         Prepare machine for CI run, clean up processes after build"
+  echo "  --nodeReuse <value>      Sets nodereuse msbuild parameter ('true' or 'false')"
+  echo "  --warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
+  echo ""
+  echo "Command line arguments starting with '/p:' are passed through to MSBuild."
+}
+
 source="${BASH_SOURCE[0]}"
 
 # resolve $source until the file is no longer a symlink
@@ -12,7 +46,6 @@ while [[ -h "$source" ]]; do
 done
 scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
 
-help=false
 restore=false
 build=false
 rebuild=false
@@ -25,8 +58,9 @@ sign=false
 public=false
 ci=false
 
-warnaserror=true
-nodereuse=true
+warn_as_error=true
+node_reuse=true
+binary_log=false
 
 projects=''
 configuration='Debug'
@@ -34,138 +68,146 @@ prepare_machine=false
 verbosity='minimal'
 properties=''
 
-while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
-  case $lowerI in
-    --build)
-      build=true
-      shift 1
-      ;;
-    --ci)
-      ci=true
-      shift 1
-      ;;
-    --configuration)
-      configuration=$2
-      shift 2
-      ;;
-    --help)
-      echo "Common settings:"
-      echo "  --configuration <value>  Build configuration Debug, Release"
-      echo "  --verbosity <value>      Msbuild verbosity (q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic])"
-      echo "  --help                   Print help and exit"
-      echo ""
-      echo "Actions:"
-      echo "  --restore                Restore dependencies"
-      echo "  --build                  Build solution"
-      echo "  --rebuild                Rebuild solution"
-      echo "  --test                   Run all unit tests in the solution"
-      echo "  --sign                   Sign build outputs"
-      echo "  --publish                Publish artifacts (e.g. symbols)"
-      echo "  --pack                   Package build outputs into NuGet packages and Willow components"
-      echo ""
-      echo "Advanced settings:"
-      echo "  --solution <value>       Path to solution to build"
-      echo "  --ci                     Set when running on CI server"
-      echo "  --prepareMachine         Prepare machine for CI run"
-      echo ""
-      echo "Command line arguments not listed above are passed through to MSBuild."
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | awk '{print tolower($0)}')"
+  case "$opt" in
+    --help|-h)
+      usage
       exit 0
       ;;
-    --pack)
-      pack=true
-      shift 1
+    --configuration|-c)
+      configuration=$2
+      shift
       ;;
-    --preparemachine)
-      prepare_machine=true
-      shift 1
+    --verbosity|-v)
+      verbosity=$2
+      shift
+      ;;
+    --binarylog|-bl)
+      binary_log=true
+      ;;
+    --restore|-r)
+      restore=true
+      ;;
+    --build|-b)
+      build=true
       ;;
     --rebuild)
       rebuild=true
-      shift 1
       ;;
-    --restore)
-      restore=true
-      shift 1
+    --pack)
+      pack=true
       ;;
-    --sign)
-      sign=true
-      shift 1
-      ;;
-    --solution)
-      solution=$2
-      shift 2
-      ;;
-    --projects)
-      projects=$2
-      shift 2
-      ;;
-    --test)
+    --test|-t)
       test=true
-      shift 1
       ;;
     --integrationtest)
       integration_test=true
-      shift 1
       ;;
     --performancetest)
       performance_test=true
-      shift 1
+      ;;
+    --sign)
+      sign=true
       ;;
     --publish)
       publish=true
-      shift 1
       ;;
-    --verbosity)
-      verbosity=$2
-      shift 2
+    --preparemachine)
+      prepare_machine=true
+      ;;
+    --projects)
+      projects=$2
+      shift
+      ;;
+    --ci)
+      ci=true
       ;;
     --warnaserror)
-      warnaserror=$2
-      shift 2
+      warn_as_error=$2
+      shift
       ;;
     --nodereuse)
-      nodereuse=$2
-      shift 2
+      node_reuse=$2
+      shift
       ;;
-      *)
+    /p:*)
       properties="$properties $1"
-      shift 1
+      ;;
+    /m:*)
+      properties="$properties $1"
+      ;;
+    /bl:*)
+      properties="$properties $1"
+      ;;
+    *)
+      echo "Invalid argument: $1"
+      usage
+      exit 1
       ;;
   esac
+
+  shift
 done
 
+if [[ "$ci" == true ]]; then
+  binary_log=true
+  node_reuse=false
+fi
+
 . "$scriptroot/tools.sh"
 
-if [[ -z $projects ]]; then
-  projects="$repo_root/*.sln"
+function InitializeCustomToolset {
+  local script="$eng_root/restore-toolset.sh"
+
+  if [[ -a "$script" ]]; then
+    . "$script"
+  fi
+}
+
+function Build {
+  InitializeToolset
+  InitializeCustomToolset
+
+  if [[ ! -z "$projects" ]]; then
+    properties="$properties /p:Projects=$projects"
+  fi
+
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:\"$log_dir/Build.binlog\""
+  fi
+
+  MSBuild $_InitializeToolset \
+    $bl \
+    /p:Configuration=$configuration \
+    /p:RepoRoot="$repo_root" \
+    /p:Restore=$restore \
+    /p:Build=$build \
+    /p:Rebuild=$rebuild \
+    /p:Test=$test \
+    /p:Pack=$pack \
+    /p:IntegrationTest=$integration_test \
+    /p:PerformanceTest=$performance_test \
+    /p:Sign=$sign \
+    /p:Publish=$publish \
+    /p:ContinuousIntegrationBuild=$ci \
+    $properties
+
+  ExitWithExitCode 0
+}
+
+# Import custom tools configuration, if present in the repo.
+configure_toolset_script="$eng_root/configure-toolset.sh"
+if [[ -a "$configure_toolset_script" ]]; then
+  . "$configure_toolset_script"
 fi
 
-InitializeTools
-
-build_log="$log_dir/Build.binlog"
-
-MSBuild "$toolset_build_proj" \
-  /bl:"$build_log" \
-  /p:Configuration=$configuration \
-  /p:Projects="$projects" \
-  /p:RepoRoot="$repo_root" \
-  /p:Restore=$restore \
-  /p:Build=$build \
-  /p:Rebuild=$rebuild \
-  /p:Test=$test \
-  /p:Pack=$pack \
-  /p:IntegrationTest=$integration_test \
-  /p:PerformanceTest=$performance_test \
-  /p:Sign=$sign \
-  /p:Publish=$publish \
-  /p:ContinuousIntegrationBuild=$ci \
-  $properties
-
-lastexitcode=$?
-
-if [[ $lastexitcode != 0 ]]; then
-  echo "Build failed (exit code '$lastexitcode'). See log: $build_log"
+# TODO: https://github.com/dotnet/arcade/issues/1468
+# Temporary workaround to avoid breaking change.
+# Remove once repos are updated.
+if [[ -n "${useInstalledDotNetCli:-}" ]]; then
+  use_installed_dotnet_cli="$useInstalledDotNetCli"
 fi
 
-ExitWithExitCode $lastexitcode
+Build
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index af182d8..96cad84 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -1,21 +1,32 @@
+param (
+    $darcVersion = $null
+)
+
 $verbosity = "m"
 . $PSScriptRoot\tools.ps1
 
-function InstallDarcCli {
+function InstallDarcCli ($darcVersion) {
   $darcCliPackageName = "microsoft.dotnet.darc"
-  $dotnet = "$env:DOTNET_INSTALL_DIR\dotnet.exe"
+
+  $dotnetRoot = InitializeDotNetCli -install:$true
+  $dotnet = "$dotnetRoot\dotnet.exe"
   $toolList = Invoke-Expression "& `"$dotnet`" tool list -g"
 
   if ($toolList -like "*$darcCliPackageName*") {
     Invoke-Expression "& `"$dotnet`" tool uninstall $darcCliPackageName -g"
   }
 
-  $toolsetVersion = $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
+  # Until we can anonymously query the BAR API for the latest arcade-services
+  # build applied to the PROD channel, this is hardcoded.
+  if (-not $darcVersion) {
+    $darcVersion = '1.1.0-beta.19057.9'
+  }
+  
+  $arcadeServicesSource = 'https://dotnetfeed.blob.core.windows.net/dotnet-arcade/index.json'
 
-  Write-Host "Installing Darc CLI version $toolsetVersion..."
+  Write-Host "Installing Darc CLI version $darcVersion..."
   Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
-  Invoke-Expression "& `"$dotnet`" tool install $darcCliPackageName --version $toolsetVersion -v $verbosity -g"
+  Invoke-Expression "& `"$dotnet`" tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -v $verbosity -g"
 }
 
-InitializeTools
-InstallDarcCli
+InstallDarcCli $darcVersion
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index a0c733a..bad07c3 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -17,10 +17,14 @@ verbosity=m
 
 function InstallDarcCli {
   local darc_cli_package_name="microsoft.dotnet.darc"
-  local uninstall_command=`$DOTNET_INSTALL_DIR/dotnet tool uninstall $darc_cli_package_name -g`
-  local tool_list=$($DOTNET_INSTALL_DIR/dotnet tool list -g)
+
+  InitializeDotNetCli
+  local dotnet_root=$_InitializeDotNetCli
+
+  local uninstall_command=`$dotnet_root/dotnet tool uninstall $darc_cli_package_name -g`
+  local tool_list=$($dotnet_root/dotnet tool list -g)
   if [[ $tool_list = *$darc_cli_package_name* ]]; then
-    echo $($DOTNET_INSTALL_DIR/dotnet tool uninstall $darc_cli_package_name -g)
+    echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
   fi
 
   ReadGlobalVersion "Microsoft.DotNet.Arcade.Sdk"
@@ -28,8 +32,7 @@ function InstallDarcCli {
 
   echo "Installing Darc CLI version $toolset_version..."
   echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
-  echo $($DOTNET_INSTALL_DIR/dotnet tool install $darc_cli_package_name --version $toolset_version -v $verbosity -g)
+  echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $toolset_version -v $verbosity -g)
 }
 
-InitializeTools
 InstallDarcCli
diff --git a/eng/common/helixpublish.proj b/eng/common/helixpublish.proj
index 364af77..d7f1858 100644
--- a/eng/common/helixpublish.proj
+++ b/eng/common/helixpublish.proj
@@ -1,4 +1,8 @@
-<Project Sdk="Microsoft.DotNet.Helix.Sdk">
+<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
+
+  <PropertyGroup>
+    <Language>msbuild</Language>
+  </PropertyGroup>
 
   <ItemGroup>
     <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
@@ -10,6 +14,13 @@
     <HelixWorkItem Include="WorkItem" Condition="'$(WorkItemDirectory)' != ''">
       <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
       <Command>$(WorkItemCommand)</Command>
+      <Timeout Condition="'$(WorkItemTimeout)' != ''">$(WorkItemTimeout)</Timeout>
     </HelixWorkItem>
   </ItemGroup>
+
+  <ItemGroup>
+    <XUnitProject Include="$(XUnitProjects.Split(';'))">
+      <Arguments />
+    </XUnitProject>
+  </ItemGroup>
 </Project>
diff --git a/eng/common/msbuild.ps1 b/eng/common/msbuild.ps1
index 43b837f..b37fd3d 100644
--- a/eng/common/msbuild.ps1
+++ b/eng/common/msbuild.ps1
@@ -1,8 +1,8 @@
 [CmdletBinding(PositionalBinding=$false)]
 Param(
   [string] $verbosity = "minimal",
-  [bool] $warnaserror = $true,
-  [bool] $nodereuse = $true,
+  [bool] $warnAsError = $true,
+  [bool] $nodeReuse = $true,
   [switch] $ci,
   [switch] $prepareMachine,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$extraArgs
@@ -11,13 +11,17 @@ Param(
 . $PSScriptRoot\tools.ps1
 
 try {
-  InitializeTools
+  if ($ci) {
+    $nodeReuse = $false
+  }
+
   MSBuild @extraArgs
-  ExitWithExitCode $lastExitCode
-}
+} 
 catch {
   Write-Host $_
   Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
   ExitWithExitCode 1
 }
+
+ExitWithExitCode 0
\ No newline at end of file
diff --git a/eng/common/msbuild.sh b/eng/common/msbuild.sh
index b102448..8160cd5 100755
--- a/eng/common/msbuild.sh
+++ b/eng/common/msbuild.sh
@@ -13,10 +13,10 @@ done
 scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
 
 verbosity='minimal'
-warnaserror=true
-nodereuse=true
+warn_as_error=true
+node_reuse=true
 prepare_machine=false
-extraargs=''
+extra_args=''
 
 while (($# > 0)); do
   lowerI="$(echo $1 | awk '{print tolower($0)}')"
@@ -26,11 +26,11 @@ while (($# > 0)); do
       shift 2
       ;;
     --warnaserror)
-      warnaserror=$2
+      warn_as_error=$2
       shift 2
       ;;
     --nodereuse)
-      nodereuse=$2
+      node_reuse=$2
       shift 2
       ;;
     --ci)
@@ -42,7 +42,7 @@ while (($# > 0)); do
       shift 1
       ;;
       *)
-      extraargs="$extraargs $1"
+      extra_args="$extra_args $1"
       shift 1
       ;;
   esac
@@ -50,6 +50,9 @@ done
 
 . "$scriptroot/tools.sh"
 
-InitializeTools
-MSBuild $extraargs
-ExitWithExitCode $?
+if [[ "$ci" == true ]]; then
+  node_reuse=false
+fi
+
+MSBuild $extra_args
+ExitWithExitCode 0
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
new file mode 100644
index 0000000..9ba7530
--- /dev/null
+++ b/eng/common/sdk-task.ps1
@@ -0,0 +1,74 @@
+[CmdletBinding(PositionalBinding=$false)]
+Param(
+  [string] $projects = "",
+  [string][Alias('v')]$verbosity = "minimal",
+  [string] $msbuildEngine = $null,
+  [bool] $warnAsError = $true,
+  [switch][Alias('bl')]$binaryLog,
+  [switch][Alias('r')]$restore,
+  [switch] $ci,
+  [switch] $prepareMachine,
+  [switch] $help,
+  [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
+)
+
+. $PSScriptRoot\tools.ps1
+
+function Print-Usage() {
+    Write-Host "Common settings:"
+    Write-Host "  -v[erbosity] <value>    Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]"
+    Write-Host "  -[bl|binaryLog]         Output binary log (short: -bl)"
+    Write-Host "  -help                   Print help and exit"
+    Write-Host ""
+
+    Write-Host "Advanced settings:"
+    Write-Host "  -restore                Restore dependencies (short: -r)"
+    Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's from the Arcade sdk to build. Globbing is supported (*.sln)"
+    Write-Host "  -ci                     Set when running on CI server"
+    Write-Host "  -prepareMachine         Prepare machine for CI run"
+    Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
+    Write-Host ""
+    Write-Host "Command line arguments not listed above are passed thru to msbuild."
+    Write-Host "The above arguments can be shortened as much as to be unambiguous (e.g. -co for configuration, -t for test, etc.)."
+}
+
+function Build {
+  $toolsetBuildProj = InitializeToolset
+
+  $toolsetBuildProj = Join-Path (Split-Path $toolsetBuildProj -Parent) "SdkTasks\SdkTask.proj"
+  $bl = if ($binaryLog) { "/bl:" + (Join-Path $LogDir "SdkTask.binlog") } else { "" }
+  MSBuild $toolsetBuildProj `
+    $bl `
+    /p:Projects=$projects `
+    /p:Restore=$restore `
+    /p:RepoRoot=$RepoRoot `
+    /p:ContinuousIntegrationBuild=$ci `
+    @properties
+}
+
+try {
+  if ($help -or (($null -ne $properties) -and ($properties.Contains("/help") -or $properties.Contains("/?")))) {
+    Print-Usage
+    exit 0
+  }
+
+  if ($projects -eq "") {
+    Write-Error "Missing required parameter '-projects <value>'"
+    Print-Usage
+    ExitWithExitCode 1
+  }
+
+  if ($ci) {
+    $binaryLog = $true
+  }
+
+  Build
+}
+catch {
+  Write-Host $_
+  Write-Host $_.Exception
+  Write-Host $_.ScriptStackTrace
+  ExitWithExitCode 1
+}
+
+ExitWithExitCode 0
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
new file mode 100644
index 0000000..5e293db
--- /dev/null
+++ b/eng/common/templates/job/job.yml
@@ -0,0 +1,205 @@
+parameters:
+# Job schema parameters - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#job
+  cancelTimeoutInMinutes: ''
+
+  condition: ''
+
+  continueOnError: false
+
+  container: ''
+
+  dependsOn: ''
+
+  displayName: ''
+
+  steps: []
+
+  pool: ''
+
+  strategy: ''
+
+  timeoutInMinutes: ''
+
+  variables: []
+
+  workspace: ''
+
+# Job base template specific parameters
+  # Optional: Enable installing Microbuild plugin
+  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
+  #             _TeamName - the name of your team
+  #             _SignType - 'test' or 'real'
+  enableMicrobuild: false
+
+  # Optional: Include PublishBuildArtifacts task
+  enablePublishBuildArtifacts: false
+
+  # Optional: Enable publishing to the build asset registry
+  enablePublishBuildAssets: false
+
+  # Optional: Include PublishTestResults task
+  enablePublishTestResults: false
+
+  # Optional: enable sending telemetry
+  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
+  #             _HelixBuildConfig - differentiate between Debug, Release, other
+  #             _HelixType - Example: build/product/
+  #             _HelixSource - Example: official/dotnet/arcade/$(Build.SourceBranch)
+  enableTelemetry: false
+
+  # Optional: If specified, then automatically derive "_HelixSource" variable for telemetry
+  helixRepo: ''
+
+  # Optional: Define the type for helix telemetry (must end in '/')
+  helixType: build/product/
+
+  # Required: name of the job
+  name: ''
+
+  # Optional: should run as a public build even in the internal project
+  #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
+  runAsPublic: false
+
+# Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
+# and some (Microbuild) should only be applied to non-PR cases for internal builds.
+
+jobs:
+- job: ${{ parameters.name }}
+
+  ${{ if ne(parameters.cancelTimeoutInMinutes, '') }}:
+    cancelTimeoutInMinutes: ${{ parameters.cancelTimeoutInMinutes }}
+
+  ${{ if ne(parameters.condition, '') }}:
+    condition: ${{ parameters.condition }}
+
+  ${{ if ne(parameters.container, '') }}:
+    container: ${{ parameters.container }}
+
+  ${{ if ne(parameters.continueOnError, '') }}:
+    continueOnError: ${{ parameters.continueOnError }}
+
+  ${{ if ne(parameters.dependsOn, '') }}:
+    dependsOn: ${{ parameters.dependsOn }}
+
+  ${{ if ne(parameters.displayName, '') }}:
+    displayName: ${{ parameters.displayName }}
+
+  ${{ if ne(parameters.pool, '') }}:
+    pool: ${{ parameters.pool }}
+
+  ${{ if ne(parameters.strategy, '') }}:
+    strategy: ${{ parameters.strategy }}
+
+  ${{ if ne(parameters.timeoutInMinutes, '') }}:
+    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
+
+  variables:
+  - ${{ each variable in parameters.variables }}:
+    # handle name-value variable syntax
+    # example:
+    # - name: [key]
+    #   value: [value]
+    - ${{ if ne(variable.name, '') }}:
+      - name: ${{ variable.name }}
+        value: ${{ variable.value }}
+    
+    # handle variable groups
+    - ${{ if ne(variable.group, '') }}:
+      - group: ${{ variable.group }}
+
+    # handle key-value variable syntax.
+    # example:
+    # - [key]: [value]
+    - ${{ if and(eq(variable.name, ''), eq(variable.group, '')) }}:
+      - ${{ each pair in variable }}:
+        - name: ${{ pair.key }}
+          value: ${{ pair.value }}
+
+  # Add additional variables
+  - ${{ if and(ne(parameters.helixRepo, ''), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notIn(variables['Build.Reason'], 'PullRequest')) }}:
+    - name: _HelixSource
+      value: official/${{ parameters.helixRepo }}/$(Build.SourceBranch)
+  - ${{ if and(ne(parameters.helixRepo, ''), or(ne(parameters.runAsPublic, 'false'), eq(variables['System.TeamProject'], 'public'), in(variables['Build.Reason'], 'PullRequest'))) }}:
+    - name: _HelixSource
+      value: pr/${{ parameters.helixRepo }}/$(Build.SourceBranch)
+  - name: _HelixType
+    value: ${{ parameters.helixType }}
+  - name: _HelixBuildConfig
+    value: $(_BuildConfig)
+
+  ${{ if ne(parameters.workspace, '') }}:
+    workspace: ${{ parameters.workspace }}
+
+  steps:
+  - ${{ if eq(parameters.enableTelemetry, 'true') }}:
+    - template: /eng/common/templates/steps/telemetry-start.yml
+      parameters:
+        buildConfig: $(_HelixBuildConfig)
+        helixSource: $(_HelixSource)
+        helixType: $(_HelixType)
+        runAsPublic: ${{ parameters.runAsPublic }}
+
+  - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
+    - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+      - task: MicroBuildSigningPlugin@2
+        displayName: Install MicroBuild plugin
+        inputs:
+          signType: $(_SignType)
+          zipSources: false
+          feedSource: https://dnceng.pkgs.visualstudio.com/_packaging/MicroBuildToolset/nuget/v3/index.json
+        env:
+          TeamName: $(_TeamName)
+        continueOnError: ${{ parameters.continueOnError }}
+        condition: and(succeeded(), in(variables['_SignType'], 'real', 'test'), eq(variables['Agent.Os'], 'Windows_NT'))
+
+  - ${{ each step in parameters.steps }}:
+    - ${{ step }}
+
+  - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
+    - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+      - task: MicroBuildCleanup@1
+        displayName: Execute Microbuild cleanup tasks  
+        condition: and(always(), in(variables['_SignType'], 'real', 'test'), eq(variables['Agent.Os'], 'Windows_NT'))
+        continueOnError: ${{ parameters.continueOnError }}
+        env:
+          TeamName: $(_TeamName)
+
+  - ${{ if eq(parameters.enableTelemetry, 'true') }}:
+    - template: /eng/common/templates/steps/telemetry-end.yml
+
+  - ${{ if eq(parameters.enablePublishBuildArtifacts, 'true') }}:
+    - task: PublishBuildArtifacts@1
+      displayName: Publish Logs to VSTS
+      inputs:
+        PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)'
+        PublishLocation: Container
+        ArtifactName: $(Agent.Os)_$(Agent.JobName)
+      continueOnError: true
+      condition: always()
+
+  - ${{ if eq(parameters.enablePublishTestResults, 'true') }}:
+    - task: PublishTestResults@2
+      displayName: Publish Test Results
+      inputs:
+        testResultsFormat: 'xUnit'
+        testResultsFiles: '*.xml' 
+        searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
+      continueOnError: true
+      condition: always()
+    
+  - ${{ if and(eq(parameters.enablePublishBuildAssets, true), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - task: CopyFiles@2
+      displayName: Gather Asset Manifests
+      inputs:
+        SourceFolder: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/AssetManifest'
+        TargetFolder: '$(Build.StagingDirectory)/AssetManifests'
+      continueOnError: ${{ parameters.continueOnError }}
+      condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
+    - task: PublishBuildArtifacts@1
+      displayName: Push Asset Manifests
+      inputs:
+        PathtoPublish: '$(Build.StagingDirectory)/AssetManifests'
+        PublishLocation: Container
+        ArtifactName: AssetManifests
+      continueOnError: ${{ parameters.continueOnError }}
+      condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
\ No newline at end of file
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
new file mode 100644
index 0000000..c094658
--- /dev/null
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -0,0 +1,63 @@
+parameters:
+  configuration: 'Debug'
+
+  # Optional: condition for the job to run
+  condition: ''
+
+  # Optional: 'true' if future jobs should run even if this job fails
+  continueOnError: false
+
+  # Optional: dependencies of the job
+  dependsOn: ''
+
+  # Optional: Include PublishBuildArtifacts task
+  enablePublishBuildArtifacts: false
+
+  # Optional: A defined YAML pool - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#pool
+  pool: {}
+
+  # Optional: should run as a public build even in the internal project
+  #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
+  runAsPublic: false
+
+jobs:
+- job: Asset_Registry_Publish
+
+  dependsOn: ${{ parameters.dependsOn }}
+
+  displayName: Publish to Build Asset Registry
+
+  pool: ${{ parameters.pool }}
+
+  variables:
+  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - name: _BuildConfig
+      value: ${{ parameters.configuration }}
+    - group: Publish-Build-Assets
+
+  steps:
+  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - task: DownloadBuildArtifacts@0
+      displayName: Download artifact
+      inputs:
+        artifactName: AssetManifests
+        downloadPath: '$(Build.StagingDirectory)/Download'
+      condition: ${{ parameters.condition }}
+      continueOnError: ${{ parameters.continueOnError }}
+    - script: eng\common\publishbuildassets.cmd
+        /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
+        /p:BuildAssetRegistryToken=$(MaestroAccessToken)
+        /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
+        /p:Configuration=$(_BuildConfig)
+      displayName: Publish Build Assets
+      condition: ${{ parameters.condition }}
+      continueOnError: ${{ parameters.continueOnError }}
+    - ${{ if eq(parameters.enablePublishBuildArtifacts, 'true') }}:
+      - task: PublishBuildArtifacts@1
+        displayName: Publish Logs to VSTS
+        inputs:
+          PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)'
+          PublishLocation: Container
+          ArtifactName: $(Agent.Os)_PublishBuildAssets
+        continueOnError: true
+        condition: always()      
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
new file mode 100644
index 0000000..c7226b1
--- /dev/null
+++ b/eng/common/templates/jobs/jobs.yml
@@ -0,0 +1,77 @@
+parameters:
+  # Optional: 'true' if failures in job.yml job should not fail the job
+  continueOnError: false
+
+  # Optional: Enable installing Microbuild plugin
+  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
+  #             _TeamName - the name of your team
+  #             _SignType - 'test' or 'real'
+  enableMicrobuild: false
+
+  # Optional: Include PublishBuildArtifacts task
+  enablePublishBuildArtifacts: false
+
+  # Optional: Enable publishing to the build asset registry
+  enablePublishBuildAssets: false
+
+  # Optional: Include PublishTestResults task
+  enablePublishTestResults: false
+
+  # Optional: enable sending telemetry
+  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
+  #             _HelixBuildConfig - differentiate between Debug, Release, other
+  #             _HelixType - Example: build/product/
+  #             _HelixSource - Example: official/dotnet/arcade/$(Build.SourceBranch)
+  enableTelemetry: false
+
+  # Required: A collection of jobs to run - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#job
+  jobs: []
+
+  # Optional: If specified, then automatically derive "_HelixSource" variable for telemetry
+  helixRepo: ''
+
+  # Optional: Define the type for helix telemetry (must end in '/')
+  helixType: build/product/
+
+  # Optional: Override automatically derived dependsOn value for "publish build assets" job
+  publishBuildAssetsDependsOn: ''
+
+  # Optional: should run as a public build even in the internal project
+  #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
+  runAsPublic: false
+
+# Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
+# and some (Microbuild) should only be applied to non-PR cases for internal builds.
+
+jobs:
+- ${{ each job in parameters.jobs }}:
+  - template: ../job/job.yml
+    parameters: 
+      # pass along parameters
+      ${{ each parameter in parameters }}:
+        ${{ if ne(parameter.key, 'jobs') }}:
+          ${{ parameter.key }}: ${{ parameter.value }}
+
+      # pass along job properties
+      ${{ each property in job }}:
+        ${{ if ne(property.key, 'job') }}:
+          ${{ property.key }}: ${{ property.value }}
+
+      name: ${{ job.job }}
+
+- ${{ if and(eq(parameters.enablePublishBuildAssets, true), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+  - template: ../job/publish-build-assets.yml
+    parameters:
+      continueOnError: ${{ parameters.continueOnError }}
+      dependsOn:
+      - ${{ if ne(parameters.publishBuildAssetsDependsOn, '') }}:
+        - ${{ each job in parameters.publishBuildAssetsDependsOn }}:
+          - ${{ job.job }}
+      - ${{ if eq(parameters.publishBuildAssetsDependsOn, '') }}:
+        - ${{ each job in parameters.jobs }}:
+          - ${{ job.job }}
+      pool:
+        vmImage: vs2017-win2016
+      runAsPublic: ${{ parameters.runAsPublic }}
+      enablePublishBuildArtifacts: ${{ parameters.enablePublishBuildArtifacts }}
+
diff --git a/eng/common/templates/phases/base.yml b/eng/common/templates/phases/base.yml
index e075e8b..0123cf4 100644
--- a/eng/common/templates/phases/base.yml
+++ b/eng/common/templates/phases/base.yml
@@ -85,7 +85,6 @@ phases:
       - task: MicroBuildSigningPlugin@2
         displayName: Install MicroBuild plugin
         inputs:
-          version: 1.1.35
           signType: $(_SignType)
           zipSources: false
           feedSource: https://dnceng.pkgs.visualstudio.com/_packaging/MicroBuildToolset/nuget/v3/index.json
diff --git a/eng/common/templates/phases/publish-build-assets.yml b/eng/common/templates/phases/publish-build-assets.yml
index 0df6203..85fabe6 100644
--- a/eng/common/templates/phases/publish-build-assets.yml
+++ b/eng/common/templates/phases/publish-build-assets.yml
@@ -29,10 +29,10 @@ phases:
           condition: ${{ parameters.condition }}
           continueOnError: ${{ parameters.continueOnError }}
         - script: eng\common\publishbuildassets.cmd
-            -configuration $(_BuildConfig)
             /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
             /p:BuildAssetRegistryToken=$(MaestroAccessToken)
             /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
+            /p:Configuration=$(_BuildConfig)
           displayName: Publish Build Assets
           condition: ${{ parameters.condition }}
           continueOnError: ${{ parameters.continueOnError }}
diff --git a/eng/common/templates/steps/helix-publish.yml b/eng/common/templates/steps/helix-publish.yml
index 6bbebd3..470ab65 100644
--- a/eng/common/templates/steps/helix-publish.yml
+++ b/eng/common/templates/steps/helix-publish.yml
@@ -26,7 +26,7 @@ steps:
       command: custom
       projects: eng/common/helixpublish.proj
       custom: msbuild
-      arguments: '/t:test /p:Language=msbuild /bl:$(Build.SourcesDirectory)\artifacts\log\$(_BuildConfig)\SendToHelix.binlog'
+      arguments: '/bl:$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/SendToHelix.binlog'
     displayName: Send job to Helix
     env:
       HelixSource: ${{ parameters.HelixSource }}
@@ -40,7 +40,8 @@ steps:
       WorkItemCommand: ${{ parameters.WorkItemCommand }}
       CorrelationPayloadDirectory: ${{ parameters.CorrelationPayloadDirectory }}
       XUnitProjects: ${{ parameters.XUnitProjects }}
-      XUnitTargetFramework: ${{ parameters.XUnitTargetFramework }}
+      XUnitRuntimeTargetFramework: ${{ parameters.XUnitTargetFramework }}
+      XUnitRunnerVersion: ${{ parameters.XUnitRunnerVersion }}
       IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
       DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
       DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
diff --git a/eng/common/templates/steps/send-to-helix.yml b/eng/common/templates/steps/send-to-helix.yml
new file mode 100644
index 0000000..a5835c0
--- /dev/null
+++ b/eng/common/templates/steps/send-to-helix.yml
@@ -0,0 +1,81 @@
+parameters:
+  HelixSource: 'pr/default'          # required -- sources must start with pr/, official/, prodcon/, or agent/
+  HelixType: 'tests/default/'        # required -- Helix telemetry which identifies what type of data this is; should include "test" for clarity and must end in '/'
+  HelixBuild: $(Build.BuildNumber)   # required -- the build number Helix will use to identify this -- automatically set to the AzDO build number
+  HelixTargetQueues: ''              # required -- semicolon delimited list of Helix queues to test on; see https://helix.dot.net/api/2018-03-14/info/queues for a list of queues
+  HelixAccessToken: ''               # required -- access token to make Helix API requests; should be provided by the appropriate variable group
+  HelixPreCommands: ''               # optional -- commands to run before Helix work item execution
+  HelixPostCommands: ''              # optional -- commands to run after Helix work item execution
+  WorkItemDirectory: ''              # optional -- a payload directory to zip up and send to Helix; requires WorkItemCommand; incompatible with XUnitProjects
+  WorkItemCommand: ''                # optional -- a command to execute on the payload; requires WorkItemDirectory; incompatible with XUnitProjects
+  WorkItemTimeout: ''                # optional -- a timeout in seconds for the work item command; requires WorkItemDirectory; incompatible with XUnitProjects
+  CorrelationPayloadDirectory: ''    # optional -- a directory to zip up and send to Helix as a correlation payload
+  XUnitProjects: ''                  # optional -- semicolon delimited list of XUnitProjects to parse and send to Helix; requires XUnitRuntimeTargetFramework, XUnitPublishTargetFramework, XUnitRunnerVersion, and IncludeDotNetCli=true
+  XUnitPublishTargetFramework: ''    # optional -- framework to use to publish your xUnit projects
+  XUnitRuntimeTargetFramework: ''    # optional -- framework to use for the xUnit console runner
+  XUnitRunnerVersion: ''             # optional -- version of the xUnit nuget package you wish to use on Helix; required for XUnitProjects
+  IncludeDotNetCli: false            # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
+  DotNetCliPackageType: ''           # optional -- either 'sdk' or 'runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
+  DotNetCliVersion: ''               # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
+  EnableXUnitReporter: false         # optional -- true enables XUnit result reporting to Mission Control
+  WaitForWorkItemCompletion: true    # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
+  IsExternal: false                  # [DEPRECATED] -- doesn't do anything, jobs are external if HelixAccessToken is empty and Creator is set
+  Creator: ''                        # optional -- if the build is external, use this to specify who is sending the job
+  condition: succeeded()             # optional -- condition for step to execute; defaults to succeeded()
+  continueOnError: false             # optional -- determines whether to continue the build if the step errors; defaults to false
+
+steps:
+  - powershell: 'powershell "$env:BUILD_SOURCESDIRECTORY\eng\common\msbuild.ps1 $env:BUILD_SOURCESDIRECTORY\eng\common\helixpublish.proj /bl:$env:BUILD_SOURCESDIRECTORY\artifacts\log\$env:BuildConfig\SendToHelix.binlog"'
+    displayName: Send job to Helix (Windows)
+    env:
+      BuildConfig: $(_BuildConfig)
+      HelixSource: ${{ parameters.HelixSource }}
+      HelixType: ${{ parameters.HelixType }}
+      HelixBuild: ${{ parameters.HelixBuild }}
+      HelixTargetQueues: ${{ parameters.HelixTargetQueues }}
+      HelixAccessToken: ${{ parameters.HelixAccessToken }}
+      HelixPreCommands: ${{ parameters.HelixPreCommands }}
+      HelixPostCommands: ${{ parameters.HelixPostCommands }}
+      WorkItemDirectory: ${{ parameters.WorkItemDirectory }}
+      WorkItemCommand: ${{ parameters.WorkItemCommand }}
+      WorkItemTimeout: ${{ parameters.WorkItemTimeout }}
+      CorrelationPayloadDirectory: ${{ parameters.CorrelationPayloadDirectory }}
+      XUnitProjects: ${{ parameters.XUnitProjects }}
+      XUnitPublishTargetFramework: ${{ parameters.XUnitPublishTargetFramework }}
+      XUnitRuntimeTargetFramework: ${{ parameters.XUnitRuntimeTargetFramework }}
+      XUnitRunnerVersion: ${{ parameters.XUnitRunnerVersion }}
+      IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
+      DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
+      DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
+      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
+      WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
+      Creator: ${{ parameters.Creator }}
+    condition: and(${{ parameters.condition }}, eq(variables['Agent.Os'], 'Windows_NT'))
+    continueOnError: ${{ parameters.continueOnError }}
+  - script: $BUILD_SOURCESDIRECTORY/eng/common/msbuild.sh $BUILD_SOURCESDIRECTORY/eng/common/helixpublish.proj /bl:$BUILD_SOURCESDIRECTORY/artifacts/log/$BuildConfig/SendToHelix.binlog
+    displayName: Send job to Helix (Unix)
+    env:
+      BuildConfig: $(_BuildConfig)
+      HelixSource: ${{ parameters.HelixSource }}
+      HelixType: ${{ parameters.HelixType }}
+      HelixBuild: ${{ parameters.HelixBuild }}
+      HelixTargetQueues: ${{ parameters.HelixTargetQueues }}
+      HelixAccessToken: ${{ parameters.HelixAccessToken }}
+      HelixPreCommands: ${{ parameters.HelixPreCommands }}
+      HelixPostCommands: ${{ parameters.HelixPostCommands }}
+      WorkItemDirectory: ${{ parameters.WorkItemDirectory }}
+      WorkItemCommand: ${{ parameters.WorkItemCommand }}
+      WorkItemTimeout: ${{ parameters.WorkItemTimeout }}
+      CorrelationPayloadDirectory: ${{ parameters.CorrelationPayloadDirectory }}
+      XUnitProjects: ${{ parameters.XUnitProjects }}
+      XUnitPublishTargetFramework: ${{ parameters.XUnitPublishTargetFramework }}
+      XUnitRuntimeTargetFramework: ${{ parameters.XUnitRuntimeTargetFramework }}
+      XUnitRunnerVersion: ${{ parameters.XUnitRunnerVersion }}
+      IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
+      DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
+      DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
+      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
+      WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
+      Creator: ${{ parameters.Creator }}
+    condition: and(${{ parameters.condition }}, ne(variables['Agent.Os'], 'Windows_NT'))
+    continueOnError: ${{ parameters.continueOnError }}
diff --git a/eng/common/templates/steps/telemetry-end.yml b/eng/common/templates/steps/telemetry-end.yml
index 9cfe360..9b61481 100644
--- a/eng/common/templates/steps/telemetry-end.yml
+++ b/eng/common/templates/steps/telemetry-end.yml
@@ -1,7 +1,3 @@
-parameters:
-  helixSource: 'undefined_defaulted_in_telemetry.yml'
-  helixType: 'undefined_defaulted_in_telemetry.yml'
-
 steps:
 - bash: |
     if [ "$AGENT_JOBSTATUS" = "Succeeded" ] || [ "$AGENT_JOBSTATUS" = "PartiallySucceeded" ]; then
diff --git a/eng/common/templates/steps/telemetry-start.yml b/eng/common/templates/steps/telemetry-start.yml
index 07f1185..79c128c 100644
--- a/eng/common/templates/steps/telemetry-start.yml
+++ b/eng/common/templates/steps/telemetry-start.yml
@@ -31,17 +31,16 @@ steps:
     }
     JobListStuff
     
+    cat $jobInfo
+
     # create a temporary file for curl output
     res=`mktemp`
 
-    accessTokenParameter=''
-    if [[ ! "$HelixApiAccessToken" == "" ]]; then
-      accessTokenParameter="?access_token=$HelixApiAccessToken"
-    fi
+    accessTokenParameter="?access_token=$HelixApiAccessToken"
 
     curlResult=`
       cat $jobInfo |\
-      curl --verbose --output $res --write-out "%{http_code}" \
+      curl --trace - --verbose --output $res --write-out "%{http_code}" \
       -H 'Content-Type: application/json' \
       -X POST "https://helix.dot.net/api/2018-03-14/telemetry/job$accessTokenParameter" -d @-`
     curlStatus=$?
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 734576e..4204dc1 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -1,14 +1,43 @@
-# Initialize variables if they aren't already defined
-
-$ci = if (Test-Path variable:ci) { $ci } else { $false }
-$configuration = if (Test-Path variable:configuration) { $configuration } else { "Debug" }
-$nodereuse = if (Test-Path variable:nodereuse) { $nodereuse } else { !$ci }
-$prepareMachine = if (Test-Path variable:prepareMachine) { $prepareMachine } else { $false }
-$restore = if (Test-Path variable:restore) { $restore } else { $true }
-$verbosity = if (Test-Path variable:verbosity) { $verbosity } else { "minimal" }
-$warnaserror = if (Test-Path variable:warnaserror) { $warnaserror } else { $true }
-$msbuildEngine = if (Test-Path variable:msbuildEngine) { $msbuildEngine } else { $null }
-$useInstalledDotNetCli = if (Test-Path variable:useInstalledDotNetCli) { $useInstalledDotNetCli } else { $true }
+# Initialize variables if they aren't already defined.
+# These may be defined as parameters of the importing script, or set after importing this script.
+
+# CI mode - set to true on CI server for PR validation build or official build.
+[bool]$ci = if (Test-Path variable:ci) { $ci } else { $false }
+
+# Build configuration. Common values include 'Debug' and 'Release', but the repository may use other names.
+[string]$configuration = if (Test-Path variable:configuration) { $configuration } else { "Debug" }
+
+# Set to true to output binary log from msbuild. Note that emitting binary log slows down the build.
+# Binary log must be enabled on CI.
+[bool]$binaryLog = if (Test-Path variable:binaryLog) { $binaryLog } else { $ci }
+
+# Turns on machine preparation/clean up code that changes the machine state (e.g. kills build processes).
+[bool]$prepareMachine = if (Test-Path variable:prepareMachine) { $prepareMachine } else { $false }
+
+# True to restore toolsets and dependencies.
+[bool]$restore = if (Test-Path variable:restore) { $restore } else { $true }
+
+# Adjusts msbuild verbosity level.
+[string]$verbosity = if (Test-Path variable:verbosity) { $verbosity } else { "minimal" }
+
+# Set to true to reuse msbuild nodes. Recommended to not reuse on CI.
+[bool]$nodeReuse = if (Test-Path variable:nodeReuse) { $nodeReuse } else { !$ci }
+
+# Configures warning treatment in msbuild.
+[bool]$warnAsError = if (Test-Path variable:warnAsError) { $warnAsError } else { $true }
+
+# Specifies which msbuild engine to use for build: 'vs', 'dotnet' or unspecified (determined based on presence of tools.vs in global.json).
+[string]$msbuildEngine = if (Test-Path variable:msbuildEngine) { $msbuildEngine } else { $null }
+
+# True to attempt using .NET Core already that meets requirements specified in global.json 
+# installed on the machine instead of downloading one.
+[bool]$useInstalledDotNetCli = if (Test-Path variable:useInstalledDotNetCli) { $useInstalledDotNetCli } else { $true }
+
+# True to use global NuGet cache instead of restoring packages to repository-local directory.
+[bool]$useGlobalNuGetCache = if (Test-Path variable:useGlobalNuGetCache) { $useGlobalNuGetCache } else { !$ci }
+
+# An array of names of processes to stop on script exit if prepareMachine is true.
+$processesToStopOnExit = if (Test-Path variable:processesToStopOnExit) { $processesToStopOnExit } else { @("msbuild", "dotnet", "vbcscompiler") }
 
 set-strictmode -version 2.0
 $ErrorActionPreference = "Stop"
@@ -20,13 +49,59 @@ function Create-Directory([string[]] $path) {
   }
 }
 
+function Unzip([string]$zipfile, [string]$outpath) {
+  Add-Type -AssemblyName System.IO.Compression.FileSystem
+  [System.IO.Compression.ZipFile]::ExtractToDirectory($zipfile, $outpath)
+}
+
+# This will exec a process using the console and return it's exit code.
+# This will not throw when the process fails.
+# Returns process exit code.
+function Exec-Process([string]$command, [string]$commandArgs) {
+  $startInfo = New-Object System.Diagnostics.ProcessStartInfo
+  $startInfo.FileName = $command
+  $startInfo.Arguments = $commandArgs
+  $startInfo.UseShellExecute = $false
+  $startInfo.WorkingDirectory = Get-Location
+
+  $process = New-Object System.Diagnostics.Process
+  $process.StartInfo = $startInfo
+  $process.Start() | Out-Null
+
+  $finished = $false
+  try {
+    while (-not $process.WaitForExit(100)) { 
+      # Non-blocking loop done to allow ctr-c interrupts
+    }
+
+    $finished = $true
+    return $global:LASTEXITCODE = $process.ExitCode
+  }
+  finally {
+    # If we didn't finish then an error occured or the user hit ctrl-c.  Either
+    # way kill the process
+    if (-not $finished) {
+      $process.Kill()
+    }
+  }
+}
+
 function InitializeDotNetCli([bool]$install) {
+  if (Test-Path variable:global:_DotNetInstallDir) {
+    return $global:_DotNetInstallDir
+  }
+
   # Don't resolve runtime, shared framework, or SDK from other locations to ensure build determinism
   $env:DOTNET_MULTILEVEL_LOOKUP=0
 
   # Disable first run since we do not need all ASP.NET packages restored.
   $env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
 
+  # Disable telemetry on CI.
+  if ($ci) {
+    $env:DOTNET_CLI_TELEMETRY_OPTOUT=1
+  }
+
   # Source Build uses DotNetCoreSdkDir variable
   if ($env:DotNetCoreSdkDir -ne $null) {
     $env:DOTNET_INSTALL_DIR = $env:DotNetCoreSdkDir
@@ -34,7 +109,10 @@ function InitializeDotNetCli([bool]$install) {
 
   # Find the first path on %PATH% that contains the dotnet.exe
   if ($useInstalledDotNetCli -and ($env:DOTNET_INSTALL_DIR -eq $null)) {
-    $env:DOTNET_INSTALL_DIR = ${env:PATH}.Split(';') | where { ($_ -ne "") -and (Test-Path (Join-Path $_ "dotnet.exe")) }
+    $dotnetCmd = Get-Command "dotnet.exe" -ErrorAction SilentlyContinue
+    if ($dotnetCmd -ne $null) {
+      $env:DOTNET_INSTALL_DIR = Split-Path $dotnetCmd.Path -Parent
+    }
   }
 
   $dotnetSdkVersion = $GlobalJson.tools.dotnet
@@ -45,9 +123,8 @@ function InitializeDotNetCli([bool]$install) {
     $dotnetRoot = $env:DOTNET_INSTALL_DIR
   } else {
     $dotnetRoot = Join-Path $RepoRoot ".dotnet"
-    $env:DOTNET_INSTALL_DIR = $dotnetRoot
 
-    if (-not (Test-Path(Join-Path $env:DOTNET_INSTALL_DIR "sdk\$dotnetSdkVersion"))) {
+    if (-not (Test-Path(Join-Path $dotnetRoot "sdk\$dotnetSdkVersion"))) {
       if ($install) {
         InstallDotNetSdk $dotnetRoot $dotnetSdkVersion
       } else {
@@ -55,9 +132,23 @@ function InitializeDotNetCli([bool]$install) {
         ExitWithExitCode 1
       }
     }
+
+    $env:DOTNET_INSTALL_DIR = $dotnetRoot
+  }
+
+  # Add dotnet to PATH. This prevents any bare invocation of dotnet in custom
+  # build steps from using anything other than what we've downloaded.
+  # It also ensures that VS msbuild will use the downloaded sdk targets.
+  $env:PATH = "$dotnetRoot;$env:PATH"
+
+  if ($ci) {
+    # Make Sure that our bootstrapped dotnet cli is avaliable in future steps of the Azure Pipelines build
+    Write-Host "##vso[task.prependpath]$dotnetRoot"
+    Write-Host "##vso[task.setvariable variable=DOTNET_MULTILEVEL_LOOKUP]0"
+    Write-Host "##vso[task.setvariable variable=DOTNET_SKIP_FIRST_TIME_EXPERIENCE]1"
   }
 
-  return $dotnetRoot
+  return $global:_DotNetInstallDir = $dotnetRoot
 }
 
 function GetDotNetInstallScript([string] $dotnetRoot) {
@@ -79,39 +170,112 @@ function InstallDotNetSdk([string] $dotnetRoot, [string] $version) {
   }
 }
 
-function InitializeVisualStudioBuild {
-  $vsToolsPath = $env:VS150COMNTOOLS
-  if ($vsToolsPath -eq $null) { 
-    $vsToolsPath = $env:VS160COMNTOOLS
+#
+# Locates Visual Studio MSBuild installation. 
+# The preference order for MSBuild to use is as follows:
+#
+#   1. MSBuild from an active VS command prompt
+#   2. MSBuild from a compatible VS installation
+#   3. MSBuild from the xcopy tool package
+#
+# Returns full path to msbuild.exe.
+# Throws on failure.
+#
+function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements = $null) {
+  if (Test-Path variable:global:_MSBuildExe) {
+    return $global:_MSBuildExe
   }
 
-  if (($vsToolsPath -ne $null) -and (Test-Path $vsToolsPath)) {
-    $vsInstallDir = [System.IO.Path]::GetFullPath((Join-Path $vsToolsPath "..\.."))
-  } else {
-    $vsInfo = LocateVisualStudio
+  if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
+  $vsMinVersionStr = if ($vsRequirements.version) { $vsRequirements.version } else { "15.9" }
+  $vsMinVersion = [Version]::new($vsMinVersionStr) 
 
+  # Try msbuild command available in the environment.
+  if ($env:VSINSTALLDIR -ne $null) {
+    $msbuildCmd = Get-Command "msbuild.exe" -ErrorAction SilentlyContinue
+    if ($msbuildCmd -ne $null) {
+      if ($msbuildCmd.Version -ge $vsMinVersion) {
+        return $global:_MSBuildExe = $msbuildCmd.Path
+      }
+
+      # Report error - the developer environment is initialized with incompatible VS version.
+      throw "Developer Command Prompt for VS $($env:VisualStudioVersion) is not recent enough. Please upgrade to $vsMinVersionStr or build from a plain CMD window"
+    }
+  }
+
+  # Locate Visual Studio installation or download x-copy msbuild.
+  $vsInfo = LocateVisualStudio $vsRequirements
+  if ($vsInfo -ne $null) {
     $vsInstallDir = $vsInfo.installationPath
-    $vsSdkInstallDir = Join-Path $vsInstallDir "VSSDK\"
-    $vsVersion = $vsInfo.installationVersion.Split('.')[0] + "0"
+    $vsMajorVersion = $vsInfo.installationVersion.Split('.')[0]
 
-    Set-Item "env:VS$($vsVersion)COMNTOOLS" (Join-Path $vsInstallDir "Common7\Tools\")    
-    Set-Item "env:VSSDK$($vsVersion)Install" $vsSdkInstallDir
+    InitializeVisualStudioEnvironmentVariables $vsInstallDir $vsMajorVersion
+  } elseif ($install) {
+
+    if (Get-Member -InputObject $GlobalJson.tools -Name "xcopy-msbuild") {
+      $xcopyMSBuildVersion = $GlobalJson.tools.'xcopy-msbuild'
+      $vsMajorVersion = $xcopyMSBuildVersion.Split('.')[0]
+    } else {
+      $vsMajorVersion = $vsMinVersion.Major
+      $xcopyMSBuildVersion = "$vsMajorVersion.$($vsMinVersion.Minor).0-alpha"
+    }
+
+    $vsInstallDir = InstallXCopyMSBuild $xcopyMSBuildVersion
+  } else {
+    throw "Unable to find Visual Studio that has required version and components installed"
+  }
+
+  $msbuildVersionDir = if ([int]$vsMajorVersion -lt 16) { "$vsMajorVersion.0" } else { "Current" }
+  return $global:_MSBuildExe = Join-Path $vsInstallDir "MSBuild\$msbuildVersionDir\Bin\msbuild.exe"
+}
+
+function InitializeVisualStudioEnvironmentVariables([string] $vsInstallDir, [string] $vsMajorVersion) {
+  $env:VSINSTALLDIR = $vsInstallDir
+  Set-Item "env:VS$($vsMajorVersion)0COMNTOOLS" (Join-Path $vsInstallDir "Common7\Tools\")
+  
+  $vsSdkInstallDir = Join-Path $vsInstallDir "VSSDK\"
+  if (Test-Path $vsSdkInstallDir) {
+    Set-Item "env:VSSDK$($vsMajorVersion)0Install" $vsSdkInstallDir
     $env:VSSDKInstall = $vsSdkInstallDir
   }
-
-  return $vsInstallDir
 }
 
-function LocateVisualStudio {
-  $vswhereVersion = $GlobalJson.tools.vswhere
+function InstallXCopyMSBuild([string] $packageVersion) {
+  $packageName = "RoslynTools.MSBuild"
+  $packageDir = Join-Path $ToolsDir "msbuild\$packageVersion"
+  $packagePath = Join-Path $packageDir "$packageName.$packageVersion.nupkg"
+
+  if (!(Test-Path $packageDir)) {
+    Create-Directory $packageDir
+    Write-Host "Downloading $packageName $packageVersion"
+    Invoke-WebRequest "https://dotnet.myget.org/F/roslyn-tools/api/v2/package/$packageName/$packageVersion/" -OutFile $packagePath
+    Unzip $packagePath $packageDir
+  }
+
+  return Join-Path $packageDir "tools"
+}
 
-  if (!$vsWhereVersion) {
-    Write-Host "vswhere version must be specified in /global.json." -ForegroundColor Red
-    ExitWithExitCode 1
+#
+# Locates Visual Studio instance that meets the minimal requirements specified by tools.vs object in global.json.
+#
+# The following properties of tools.vs are recognized:
+#   "version": "{major}.{minor}"    
+#       Two part minimal VS version, e.g. "15.9", "16.0", etc.
+#   "components": ["componentId1", "componentId2", ...] 
+#       Array of ids of workload components that must be available in the VS instance.
+#       See e.g. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-enterprise?view=vs-2017
+#
+# Returns JSON describing the located VS instance (same format as returned by vswhere), 
+# or $null if no instance meeting the requirements is found on the machine.
+#
+function LocateVisualStudio([object]$vsRequirements = $null){
+  if (Get-Member -InputObject $GlobalJson.tools -Name "vswhere") {
+    $vswhereVersion = $GlobalJson.tools.vswhere
+  } else {
+    $vswhereVersion = "2.5.2"
   }
 
-  $toolsRoot = Join-Path $RepoRoot ".tools"
-  $vsWhereDir = Join-Path $toolsRoot "vswhere\$vswhereVersion"
+  $vsWhereDir = Join-Path $ToolsDir "vswhere\$vswhereVersion"
   $vsWhereExe = Join-Path $vsWhereDir "vswhere.exe"
 
   if (!(Test-Path $vsWhereExe)) {
@@ -120,86 +284,112 @@ function LocateVisualStudio {
     Invoke-WebRequest "https://github.com/Microsoft/vswhere/releases/download/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
   }
 
-  $vsInfo = & $vsWhereExe `
-    -latest `
-    -prerelease `
-    -format json `
-    -requires Microsoft.Component.MSBuild `
-    -requires Microsoft.VisualStudio.Component.VSSDK `
-    -requires Microsoft.VisualStudio.Component.Roslyn.Compiler | ConvertFrom-Json
+  if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
+  $args = @("-latest", "-prerelease", "-format", "json", "-requires", "Microsoft.Component.MSBuild")
+  
+  if (Get-Member -InputObject $vsRequirements -Name "version") {
+    $args += "-version"
+    $args += $vsRequirements.version
+  }
+
+  if (Get-Member -InputObject $vsRequirements -Name "components") {
+    foreach ($component in $vsRequirements.components) {
+      $args += "-requires"
+      $args += $component
+    }    
+  }
+
+  $vsInfo =& $vsWhereExe $args | ConvertFrom-Json
 
   if ($lastExitCode -ne 0) {
-    Write-Host "Failed to locate Visual Studio (exit code '$lastExitCode')." -ForegroundColor Red
-    ExitWithExitCode $lastExitCode
+    return $null
   }
 
   # use first matching instance
   return $vsInfo[0]
 }
 
-function ConfigureTools { 
-  # Include custom tools configuration
-  $script = Join-Path $EngRoot "configure-toolset.ps1"
-
-  if (Test-Path $script) {
-    . $script
+function InitializeBuildTool() {
+  if (Test-Path variable:global:_BuildTool) {
+    return $global:_BuildTool
   }
-}
-
-function InitializeTools() {
-  ConfigureTools
 
-  $tools = $GlobalJson.tools
+  if (-not $msbuildEngine) {
+    $msbuildEngine = GetDefaultMSBuildEngine
+  }
 
   # Initialize dotnet cli if listed in 'tools'
   $dotnetRoot = $null
-  if ((Get-Member -InputObject $tools -Name "dotnet") -ne $null) {
+  if (Get-Member -InputObject $GlobalJson.tools -Name "dotnet") {
     $dotnetRoot = InitializeDotNetCli -install:$restore
   }
 
-  if (-not $msbuildEngine) {
-    # Presence of vswhere.version indicates the repo needs to build using VS msbuild.
-    if ((Get-Member -InputObject $tools -Name "vswhere") -ne $null) {
-      $msbuildEngine = "vs"
-    } elseif ($dotnetRoot -ne $null) {
-      $msbuildEngine = "dotnet"
-    } else {
-      Write-Host "-msbuildEngine must be specified, or /global.json must specify 'tools.dotnet' or 'tools.vswhere'." -ForegroundColor Red
-      ExitWithExitCode 1
-    }
-  }
-
   if ($msbuildEngine -eq "dotnet") {
     if (!$dotnetRoot) {
       Write-Host "/global.json must specify 'tools.dotnet'." -ForegroundColor Red
       ExitWithExitCode 1
     }
 
-    $script:buildDriver = Join-Path $dotnetRoot "dotnet.exe"
-    $script:buildArgs = "msbuild"
+    $buildTool = @{ Path = Join-Path $dotnetRoot "dotnet.exe"; Command = "msbuild" }
   } elseif ($msbuildEngine -eq "vs") {
-    $vsInstallDir = InitializeVisualStudioBuild
+    try {
+      $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
+    } catch {
+      Write-Host $_ -ForegroundColor Red
+      ExitWithExitCode 1
+    }
 
-    $script:buildDriver = Join-Path $vsInstallDir "MSBuild\15.0\Bin\msbuild.exe"
-    $script:buildArgs = ""
+    $buildTool = @{ Path = $msbuildPath; Command = "" }
   } else {
     Write-Host "Unexpected value of -msbuildEngine: '$msbuildEngine'." -ForegroundColor Red
     ExitWithExitCode 1
   }
 
-  InitializeToolSet $script:buildDriver $script:buildArgs
-  InitializeCustomToolset
+  return $global:_BuildTool = $buildTool
 }
 
-function InitializeToolset([string] $buildDriver, [string]$buildArgs) {
+function GetDefaultMSBuildEngine() {
+  # Presence of tools.vs indicates the repo needs to build using VS msbuild on Windows.
+  if (Get-Member -InputObject $GlobalJson.tools -Name "vs") {
+    return "vs"
+  }
+  
+  if (Get-Member -InputObject $GlobalJson.tools -Name "dotnet") {
+    return "dotnet"
+  }
+
+  Write-Host "-msbuildEngine must be specified, or /global.json must specify 'tools.dotnet' or 'tools.vs'." -ForegroundColor Red
+  ExitWithExitCode 1
+}
+
+function GetNuGetPackageCachePath() {
+  if ($env:NUGET_PACKAGES -eq $null) {
+    # Use local cache on CI to ensure deterministic build,
+    # use global cache in dev builds to avoid cost of downloading packages.
+    if ($useGlobalNuGetCache) {
+      $env:NUGET_PACKAGES = Join-Path $env:UserProfile ".nuget\packages"
+    } else {
+      $env:NUGET_PACKAGES = Join-Path $RepoRoot ".packages"
+    }
+  }
+
+  return $env:NUGET_PACKAGES
+}
+
+function InitializeToolset() {
+  if (Test-Path variable:global:_ToolsetBuildProj) {
+    return $global:_ToolsetBuildProj
+  }
+
+  $nugetCache = GetNuGetPackageCachePath
+
   $toolsetVersion = $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
   $toolsetLocationFile = Join-Path $ToolsetDir "$toolsetVersion.txt"
 
   if (Test-Path $toolsetLocationFile) {
     $path = Get-Content $toolsetLocationFile -TotalCount 1
     if (Test-Path $path) {
-      $script:ToolsetBuildProj = $path
-      return
+      return $global:_ToolsetBuildProj = $path
     }
   }
 
@@ -208,35 +398,20 @@ function InitializeToolset([string] $buildDriver, [string]$buildArgs) {
     ExitWithExitCode 1
   }
 
-  $ToolsetRestoreLog = Join-Path $LogDir "ToolsetRestore.binlog"
+  $buildTool = InitializeBuildTool
+
   $proj = Join-Path $ToolsetDir "restore.proj"
-
+  $bl = if ($binaryLog) { "/bl:" + (Join-Path $LogDir "ToolsetRestore.binlog") } else { "" }
+  
   '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' | Set-Content $proj
-  MSBuild $proj /t:__WriteToolsetLocation /clp:None /bl:$ToolsetRestoreLog /p:__ToolsetLocationOutputFile=$toolsetLocationFile
-
-  if ($lastExitCode -ne 0) {
-    Write-Host "Failed to restore toolset (exit code '$lastExitCode'). See log: $ToolsetRestoreLog" -ForegroundColor Red
-    ExitWithExitCode $lastExitCode
-  }
-
+  MSBuild $proj $bl /t:__WriteToolsetLocation /noconsolelogger /p:__ToolsetLocationOutputFile=$toolsetLocationFile
+  
   $path = Get-Content $toolsetLocationFile -TotalCount 1
   if (!(Test-Path $path)) {
     throw "Invalid toolset path: $path"
   }
-
-  $script:ToolsetBuildProj = $path
-}
-
-function InitializeCustomToolset {
-  if (-not $restore) {
-    return
-  }
-
-  $script = Join-Path $EngRoot "restore-toolset.ps1"
-
-  if (Test-Path $script) {
-    . $script
-  }
+  
+  return $global:_ToolsetBuildProj = $path
 }
 
 function ExitWithExitCode([int] $exitCode) {
@@ -248,36 +423,86 @@ function ExitWithExitCode([int] $exitCode) {
 
 function Stop-Processes() {
   Write-Host "Killing running build processes..."
-  Get-Process -Name "msbuild" -ErrorAction SilentlyContinue | Stop-Process
-  Get-Process -Name "dotnet" -ErrorAction SilentlyContinue | Stop-Process
-  Get-Process -Name "vbcscompiler" -ErrorAction SilentlyContinue | Stop-Process
+  foreach ($processName in $processesToStopOnExit) {
+    Get-Process -Name $processName -ErrorAction SilentlyContinue | Stop-Process
+  }
 }
 
-function MsBuild() {
-  $warnaserrorSwitch = if ($warnaserror) { "/warnaserror" } else { "" }
-  & $buildDriver $buildArgs $warnaserrorSwitch /m /nologo /clp:Summary /v:$verbosity /nr:$nodereuse $args
+#
+# Executes msbuild (or 'dotnet msbuild') with arguments passed to the function.
+# The arguments are automatically quoted.
+# Terminates the script if the build fails.
+#
+function MSBuild() {
+  if ($ci) {
+    if (!$binaryLog) {
+      throw "Binary log must be enabled in CI build."
+    }
+
+    if ($nodeReuse) {
+      throw "Node reuse must be disabled in CI build."
+    }
+  }
+
+  $buildTool = InitializeBuildTool
+
+  $cmdArgs = "$($buildTool.Command) /m /nologo /clp:Summary /v:$verbosity /nr:$nodeReuse"
+
+  if ($warnAsError) { 
+    $cmdArgs += " /warnaserror /p:TreatWarningsAsErrors=true" 
+  }
+
+  foreach ($arg in $args) {
+    if ($arg -ne $null -and $arg.Trim() -ne "") {
+      $cmdArgs += " `"$arg`""
+    }
+  }
+  
+  $exitCode = Exec-Process $buildTool.Path $cmdArgs
+
+  if ($exitCode -ne 0) {
+    Write-Host "Build failed." -ForegroundColor Red
+
+    $buildLog = GetMSBuildBinaryLogCommandLineArgument $args
+    if ($buildLog -ne $null) {      
+      Write-Host "See log: $buildLog" -ForegroundColor DarkGray 
+    }
+
+    ExitWithExitCode $exitCode
+  }
+}
+
+function GetMSBuildBinaryLogCommandLineArgument($arguments) {  
+  foreach ($argument in $arguments) {
+    if ($argument -ne $null) {
+      $arg = $argument.Trim()
+      if ($arg.StartsWith("/bl:", "OrdinalIgnoreCase")) {
+        return $arg.Substring("/bl:".Length)
+      } 
+        
+      if ($arg.StartsWith("/binaryLogger:", "OrdinalIgnoreCase")) {
+        return $arg.Substring("/binaryLogger:".Length)
+      }
+    }
+  }
+
+  return $null
 }
 
 $RepoRoot = Resolve-Path (Join-Path $PSScriptRoot "..\..")
 $EngRoot = Resolve-Path (Join-Path $PSScriptRoot "..")
 $ArtifactsDir = Join-Path $RepoRoot "artifacts"
 $ToolsetDir = Join-Path $ArtifactsDir "toolset"
+$ToolsDir = Join-Path $RepoRoot ".tools"
 $LogDir = Join-Path (Join-Path $ArtifactsDir "log") $configuration
 $TempDir = Join-Path (Join-Path $ArtifactsDir "tmp") $configuration
 $GlobalJson = Get-Content -Raw -Path (Join-Path $RepoRoot "global.json") | ConvertFrom-Json
 
-if ($env:NUGET_PACKAGES -eq $null) {
-  # Use local cache on CI to ensure deterministic build,
-  # use global cache in dev builds to avoid cost of downloading packages.
-  $env:NUGET_PACKAGES = if ($ci) { Join-Path $RepoRoot ".packages" }
-                        else { Join-Path $env:UserProfile ".nuget\packages" }
-}
-
 Create-Directory $ToolsetDir
+Create-Directory $TempDir
 Create-Directory $LogDir
 
 if ($ci) {
-  Create-Directory $TempDir
   $env:TEMP = $TempDir
   $env:TMP = $TempDir
 }
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index c7d03ee..8a253be 100644
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -1,32 +1,49 @@
-#!/usr/bin/env bash
-
-# Stop script if unbound variable found (use ${var:-} if intentional)
-set -u
+# Initialize variables if they aren't already defined.
 
+# CI mode - set to true on CI server for PR validation build or official build.
 ci=${ci:-false}
+
+# Build configuration. Common values include 'Debug' and 'Release', but the repository may use other names.
 configuration=${configuration:-'Debug'}
-nodereuse=${nodereuse:-true}
+
+# Set to true to output binary log from msbuild. Note that emitting binary log slows down the build.
+# Binary log must be enabled on CI.
+binary_log=${binary_log:-$ci}
+
+# Turns on machine preparation/clean up code that changes the machine state (e.g. kills build processes).
 prepare_machine=${prepare_machine:-false}
+
+# True to restore toolsets and dependencies.
 restore=${restore:-true}
+
+# Adjusts msbuild verbosity level.
 verbosity=${verbosity:-'minimal'}
-warnaserror=${warnaserror:-true}
-useInstalledDotNetCli=${useInstalledDotNetCli:-true}
 
-repo_root="$scriptroot/../.."
-eng_root="$scriptroot/.."
-artifacts_dir="$repo_root/artifacts"
-toolset_dir="$artifacts_dir/toolset"
-log_dir="$artifacts_dir/log/$configuration"
-temp_dir="$artifacts_dir/tmp/$configuration"
+# Set to true to reuse msbuild nodes. Recommended to not reuse on CI.
+if [[ "$ci" == true ]]; then
+  node_reuse=${node_reuse:-false}
+else
+  node_reuse=${node_reuse:-true}
+fi
 
-global_json_file="$repo_root/global.json"
-build_driver=""
-toolset_build_proj=""
+# Configures warning treatment in msbuild.
+warn_as_error=${warn_as_error:-true}
 
+# True to attempt using .NET Core already that meets requirements specified in global.json 
+# installed on the machine instead of downloading one.
+use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
+
+# True to use global NuGet cache instead of restoring packages to repository-local directory.
+if [[ "$ci" == true ]]; then
+  use_global_nuget_cache=${use_global_nuget_cache:-false}
+else
+  use_global_nuget_cache=${use_global_nuget_cache:-true}
+fi
+
+# Resolve any symlinks in the given path.
 function ResolvePath {
   local path=$1
 
-  # resolve $path until the file is no longer a symlink
   while [[ -h $path ]]; do
     local dir="$( cd -P "$( dirname "$path" )" && pwd )"
     path="$(readlink "$path")"
@@ -57,6 +74,10 @@ function ReadGlobalVersion {
 }
 
 function InitializeDotNetCli {
+  if [[ -n "${_InitializeDotNetCli:-}" ]]; then
+    return
+  fi
+
   local install=$1
 
   # Don't resolve runtime, shared framework, or SDK from other locations to ensure build determinism
@@ -65,13 +86,22 @@ function InitializeDotNetCli {
   # Disable first run since we want to control all package sources
   export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
 
+  # Disable telemetry on CI
+  if [[ $ci == true ]]; then
+    export DOTNET_CLI_TELEMETRY_OPTOUT=1
+  fi
+
+  # LTTNG is the logging infrastructure used by Core CLR. Need this variable set
+  # so it doesn't output warnings to the console.
+  export LTTNG_HOME="$HOME"
+
   # Source Build uses DotNetCoreSdkDir variable
   if [[ -n "${DotNetCoreSdkDir:-}" ]]; then
     export DOTNET_INSTALL_DIR="$DotNetCoreSdkDir"
   fi
 
   # Find the first path on $PATH that contains the dotnet.exe
-  if [[ "$useInstalledDotNetCli" == true && -z "${DOTNET_INSTALL_DIR:-}" ]]; then
+  if [[ "$use_installed_dotnet_cli" == true && -z "${DOTNET_INSTALL_DIR:-}" ]]; then
     local dotnet_path=`command -v dotnet`
     if [[ -n "$dotnet_path" ]]; then
       ResolvePath "$dotnet_path"
@@ -101,6 +131,17 @@ function InitializeDotNetCli {
     fi
   fi
 
+  # Add dotnet to PATH. This prevents any bare invocation of dotnet in custom
+  # build steps from using anything other than what we've downloaded.
+  export PATH="$dotnet_root:$PATH"
+
+  if [[ $ci == true ]]; then
+    # Make Sure that our bootstrapped dotnet cli is avaliable in future steps of the Azure Pipelines build
+    echo "##vso[task.prependpath]$dotnet_root"
+    echo "##vso[task.setvariable variable=DOTNET_MULTILEVEL_LOOKUP]0"
+    echo "##vso[task.setvariable variable=DOTNET_SKIP_FIRST_TIME_EXPERIENCE]1"
+  fi
+
   # return value
   _InitializeDotNetCli="$dotnet_root"
 }
@@ -112,13 +153,11 @@ function InstallDotNetSdk {
   GetDotNetInstallScript "$root"
   local install_script=$_GetDotNetInstallScript
 
-  bash "$install_script" --version $version --install-dir "$root"
-  local lastexitcode=$?
-
-  if [[ $lastexitcode != 0 ]]; then
-    echo "Failed to install dotnet SDK (exit code '$lastexitcode')." >&2
-    ExitWithExitCode $lastexitcode
-  fi
+  bash "$install_script" --version $version --install-dir "$root" || {
+    local exit_code=$?
+    echo "Failed to install dotnet SDK (exit code '$exit_code')." >&2
+    ExitWithExitCode $exit_code
+  }
 }
 
 function GetDotNetInstallScript {
@@ -143,7 +182,38 @@ function GetDotNetInstallScript {
   _GetDotNetInstallScript="$install_script"
 }
 
+function InitializeBuildTool {
+  if [[ -n "${_InitializeBuildTool:-}" ]]; then
+    return
+  fi
+  
+  InitializeDotNetCli $restore
+
+  # return values
+  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"  
+  _InitializeBuildToolCommand="msbuild"
+}
+
+function GetNuGetPackageCachePath {
+  if [[ -z ${NUGET_PACKAGES:-} ]]; then
+    if [[ "$use_global_nuget_cache" == true ]]; then
+      export NUGET_PACKAGES="$HOME/.nuget/packages"
+    else
+      export NUGET_PACKAGES="$repo_root/.packages"
+    fi
+  fi
+
+  # return value
+  _GetNuGetPackageCachePath=$NUGET_PACKAGES
+}
+
 function InitializeToolset {
+  if [[ -n "${_InitializeToolset:-}" ]]; then
+    return
+  fi
+
+  GetNuGetPackageCachePath
+
   ReadGlobalVersion "Microsoft.DotNet.Arcade.Sdk"
 
   local toolset_version=$_ReadGlobalVersion
@@ -152,7 +222,8 @@ function InitializeToolset {
   if [[ -a "$toolset_location_file" ]]; then
     local path=`cat "$toolset_location_file"`
     if [[ -a "$path" ]]; then
-      toolset_build_proj="$path"
+      # return value
+      _InitializeToolset="$path"
       return
     fi
   fi
@@ -166,47 +237,17 @@ function InitializeToolset {
   local proj="$toolset_dir/restore.proj"
 
   echo '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' > "$proj"
+  MSBuild "$proj" /t:__WriteToolsetLocation /noconsolelogger /bl:"$toolset_restore_log" /p:__ToolsetLocationOutputFile="$toolset_location_file"
 
-  MSBuild "$proj" /t:__WriteToolsetLocation /clp:None /bl:"$toolset_restore_log" /p:__ToolsetLocationOutputFile="$toolset_location_file"
-  local lastexitcode=$?
-
-  if [[ $lastexitcode != 0 ]]; then
-    echo "Failed to restore toolset (exit code '$lastexitcode'). See log: $toolset_restore_log" >&2
-    ExitWithExitCode $lastexitcode
-  fi
-
-  toolset_build_proj=`cat "$toolset_location_file"`
+  local toolset_build_proj=`cat "$toolset_location_file"`
 
   if [[ ! -a "$toolset_build_proj" ]]; then
     echo "Invalid toolset path: $toolset_build_proj" >&2
     ExitWithExitCode 3
   fi
-}
 
-function InitializeCustomToolset {
-  local script="$eng_root/restore-toolset.sh"
-
-  if [[ -a "$script" ]]; then
-    . "$script"
-  fi
-}
-
-function ConfigureTools {
-  local script="$eng_root/configure-toolset.sh"
-
-  if [[ -a "$script" ]]; then
-    . "$script"
-  fi
-}
-
-function InitializeTools {
-  ConfigureTools
-
-  InitializeDotNetCli $restore
-  build_driver="$_InitializeDotNetCli/dotnet"
-
-  InitializeToolset
-  InitializeCustomToolset
+  # return value
+  _InitializeToolset="$toolset_build_proj"
 }
 
 function ExitWithExitCode {
@@ -218,41 +259,61 @@ function ExitWithExitCode {
 
 function StopProcesses {
   echo "Killing running build processes..."
-  pkill -9 "dotnet"
-  pkill -9 "vbcscompiler"
+  pkill -9 "dotnet" || true
+  pkill -9 "vbcscompiler" || true
   return 0
 }
 
 function MSBuild {
+  if [[ "$ci" == true ]]; then
+    if [[ "$binary_log" != true ]]; then
+      echo "Binary log must be enabled in CI build." >&2
+      ExitWithExitCode 1
+    fi
+
+    if [[ "$node_reuse" == true ]]; then
+      echo "Node reuse must be disabled in CI build." >&2
+      ExitWithExitCode 1
+    fi
+  fi
+
+  InitializeBuildTool
+
   local warnaserror_switch=""
-  if [[ $warnaserror == true ]]; then
+  if [[ $warn_as_error == true ]]; then
     warnaserror_switch="/warnaserror"
   fi
 
-  "$build_driver" msbuild /m /nologo /clp:Summary /v:$verbosity /nr:$nodereuse $warnaserror_switch "$@"
-
-  return $?
+  "$_InitializeBuildTool" "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error "$@" || {
+    local exit_code=$?
+    echo "Build failed (exit code '$exit_code')." >&2
+    ExitWithExitCode $exit_code
+  }
 }
 
+ResolvePath "${BASH_SOURCE[0]}"
+_script_dir=`dirname "$_ResolvePath"`
+
+eng_root=`cd -P "$_script_dir/.." && pwd`
+repo_root=`cd -P "$_script_dir/../.." && pwd`
+artifacts_dir="$repo_root/artifacts"
+toolset_dir="$artifacts_dir/toolset"
+log_dir="$artifacts_dir/log/$configuration"
+temp_dir="$artifacts_dir/tmp/$configuration"
+
+global_json_file="$repo_root/global.json"
+
 # HOME may not be defined in some scenarios, but it is required by NuGet
 if [[ -z $HOME ]]; then
   export HOME="$repo_root/artifacts/.home/"
   mkdir -p "$HOME"
 fi
 
-if [[ -z ${NUGET_PACKAGES:-} ]]; then
-  if [[ $ci == true ]]; then
-    export NUGET_PACKAGES="$repo_root/.packages"
-  else
-    export NUGET_PACKAGES="$HOME/.nuget/packages"
-  fi
-fi
-
 mkdir -p "$toolset_dir"
+mkdir -p "$temp_dir"
 mkdir -p "$log_dir"
 
 if [[ $ci == true ]]; then
-  mkdir -p "$temp_dir"
   export TEMP="$temp_dir"
   export TMP="$temp_dir"
 fi
diff --git a/eng/configure-toolset.ps1 b/eng/configure-toolset.ps1
index df9fe3a..03cb64e 100644
--- a/eng/configure-toolset.ps1
+++ b/eng/configure-toolset.ps1
@@ -1,5 +1,5 @@
-# We depend on a local cli for a number of our buildtool
-# commands like init-tools so for now we need to disable
-# using the globally installed dotnet
+# We can't use already installed dotnet cli since we need to install additional shared runtimes.
+# We could potentially try to find an existing installation that has all the required runtimes,
+# but it's unlikely one will be available.
 
-$script:useInstalledDotNetCli = $false
\ No newline at end of file
+$useInstalledDotNetCli = $false
diff --git a/eng/configure-toolset.sh b/eng/configure-toolset.sh
new file mode 100644
index 0000000..3924662
--- /dev/null
+++ b/eng/configure-toolset.sh
@@ -0,0 +1,5 @@
+# We can't use already installed dotnet cli since we need to install additional shared runtimes.
+# We could potentially try to find an existing installation that has all the required runtimes,
+# but it's unlikely one will be available.
+
+useInstalledDotNetCli="false"
\ No newline at end of file
-- 
2.18.0

